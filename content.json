[{"title":"React开发中需要注意的一些内容","date":"2020-04-05T14:35:22.000Z","path":"2020/04/05/React开发中需要注意的一些内容/","text":"主要用于记录在 React 项目开发中踩过的坑，或者没有了解过的东西(持续更新)前端学无止境 ヾ(ﾟ ∀ ﾟゞ)秃头从未停止 ヾ(ﾟ ∀ ﾟゞ) react 里的逻辑性好强啊，原生 JS 重要性凸显出来了 本文作者:人模人样的搬砖老段本文链接:React 开发中需要注意的一些内容如有错误，请及时评论或者知乎私信或者 B 站私信哦~","tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"},{"name":"项目开发","slug":"项目开发","permalink":"http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"},{"name":"注意点","slug":"注意点","permalink":"http://yoursite.com/tags/%E6%B3%A8%E6%84%8F%E7%82%B9/"},{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"关于redux","date":"2020-03-22T01:04:57.000Z","path":"2020/03/22/关于redux/","text":"Redux 简介先放一下 redux 官网，多读一读官方文档总是有好处的。redux 官网 redux 是一个用于 Javascript 应用的可预测状态容器 **可预测:**reducer 是个纯函数，有怎样的输入就有怎样的输出，reducer 接收旧庄台和 action 集合，经过某些操作返回新状态，其状态规则都是开发者站在上帝视角设定好的，新状态可预测。**状态容器:**store 用来存储 state，集中统一管理树状结构。**Jsvascript 应用:**Redux 是独立的库，可通用于各种 Javascript 应用，不仅仅是 react。 redux 的设计思想很简单 Web 应用是一个状态机，视图与状态是一一对应的。 所有的状态，保存在一个对象里。 Redux 模型 Store: Store 意为数据仓库，是保存数据的地方，整个应用只能有一个 store。 12import &#123;createStore&#125; from &#39;redux&#39;const store &#x3D; createStore(fn) createStore 函数接受另一个函数作为参数，返回新生成的 Store 对象。 State: State 就是数据，数据都存在仓库里，怎么去获取仓库里的数据呢？ 1234import &#123;createStore&#125; from &#39;redux&#39;const store &#x3D; createStore(fn)const state &#x3D; store.getState() 通过 getState()来获取仓库中的数据。 reducer: Reducer 是一个纯函数，只要是同样的输入，必定得到同样的输出纯函数的一些规则: 不能修改参数 不能调用系统 I/O 的 API 不能调用 Date.now()或者 Math.random()等不纯的方法，因为每次会得到不一样的结果 12345678910const reducer = (state = defaultState, action) =&gt; &#123; switch (action.type) &#123; case \"INCREMENT\": return state + 1; case \"DECREMENT\": return state - 1; default: return state; &#125;&#125;; 未完待续…… 参考文章阮一峰大佬的文章:Redux 入门教程（一）：基本用法Redux 入门教程（二）：中间件与异步操作Redux 入门教程（三）：React-Redux 的用法 本文作者:人模人样的搬砖老段本文链接:关于 redux如有错误，请及时评论或者知乎私信或者 B 站私信哦~","tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"},{"name":"redux","slug":"redux","permalink":"http://yoursite.com/tags/redux/"}]},{"title":"关于vuex","date":"2020-03-08T05:44:44.000Z","path":"2020/03/08/关于vuex/","text":"初识 Vuex关于 VuexVuex 是适用于在 Vue 项目开发时使用的状态管理工具。试想一下，如果在一个项目开发中频繁的使用组件传参的方式来同步 data 中的值，一旦项目变得很庞大，管理和维护这些值将是相当棘手的工作。为此，Vue 为这些被多个组件频繁使用的值提供了一个统一管理的工具——VueX。在具有 Vuex 的 Vue 项目中，我们只需要把这些值定义在 Vuex 中，即可在整个 Vue 项目的组件中使用。 安装由于 Vuex 是在学习 VueCli 后进行的，所以在下文出现的项目的目录请参照 VueCli 2.x 构建的目录。 以下步骤的前提是你已经完成了 Vue 项目构建，并且已转至该项目的文件目录下。 npm 安装 Vuex 1npm i vuex -s 在项目的根目录下新增一个store文件夹，在该文件夹内创建 index.js此时你的项目的src文件夹应当是这样的 1234567891011121314│ App.vue│ main.js│├─assets│ logo.png│├─components│ HelloWorld.vue│├─router│ index.js│└─store index.js 使用 初始化 store 下 index.js 中的内容 123456789101112131415import Vue from 'vue'import Vuex from 'vuex'//挂载VuexVue.use(Vuex)//创建VueX对象const store = new Vuex.Store(&#123; state:&#123; //存放的键值对就是所要管理的状态 name:'helloVueX' &#125;&#125;)export default store 将 store 挂载到当前项目的 Vue 实例当中去打开 main.js 1234567891011121314import Vue from 'vue'import App from './App'import router from './router'import store from './store'Vue.config.productionTip = false/* eslint-disable no-new */new Vue(&#123; el: '#app', router, store, //store:store 和router一样，将我们创建的Vuex实例挂载到这个vue实例中 render: h =&gt; h(App)&#125;) 在组件中使用Vuex例如在 App.vue 中，我们要将 state 中定义的 name 拿来在 h1 标签中显示 123456&lt;template&gt; &lt;div id&#x3D;&quot;app&quot;&gt; name: &lt;h1&gt;&#123;&#123; $store.state.name &#125;&#125;&lt;&#x2F;h1&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt; 注意，请不要在此处更改state中的状态的值，后文中将会说明 安装 Vue 开发工具 VueDevtools在 Vue 项目开发中，需要监控项目中得各种值，为了提高效率，Vue 提供了一款浏览器扩展——VueDevtools。 在学习 VueX 时，更为需要使用该插件。关于该插件的使用可以移步官网，在此不再赘叙。 Vuex 中的核心内容在 Vuex 对象中，其实不止有 state,还有用来操作 state 中数据的方法集，以及当我们需要对 state 中的数据需要加工的方法集等等成员。 成员列表： state 存放状态 mutations state 成员操作 getters 加工 state 成员给外界 actions 异步操作 modules 模块化状态管理 Vuex 的工作流程 首先，Vue 组件如果调用某个 Vuex 的方法过程中需要向后端请求时或者说出现异步操作时，需要 dispatch Vuex 中 actions 的方法，以保证数据的同步。可以说，action 的存在就是为了让 mutations 中的方法能在异步操作中起作用。 如果没有异步操作，那么我们就可以直接在组件内提交状态中的Mutations中自己编写的方法来达成对state成员的操作。注意，上文中有提到，不建议在组件中直接对state中的成员进行操作，这是因为直接修改(例如：this.$store.state.name = &#39;hello&#39;)的话不能被VueDevtools所监控到。 最后被修改后的 state 成员会被渲染到组件的原位置当中去。 Mutationsmutations是操作state数据的方法的集合，比如对该数据的修改、增加、删除等等。 Mutations 使用方法 Mutations 方法都有默认的形参: 1([state], [payload]); state 方法时当前 Vuex 对象中的 state payload 是该方法在被调用传递参数时使用 例如，我们编写一个方法，当被执行时，能把下例中的 name 值修改为”jack”,我们只需要这样做 index.js 123456789101112131415161718import Vue from \"vue\";import Vuex from \"vuex\";Vue.use(Vuex);const store = new Vuex.store(&#123; state: &#123; name: \"helloVueX\", &#125;, mutations: &#123; //es6语法，等同edit:funcion()&#123;...&#125; edit(state) &#123; state.name = \"jack\"; &#125;, &#125;,&#125;);export default store; 而在组件中，我们需要这样去调用这个mutation——例如在 App.vue 的某个method中: 1this.$store.commit(\"edit\"); Mutation 传值 在实际生产过程中，会遇到需要在提交某个 mutation 时需要携带一些参数给方法使用。 单个值提交时: 1this.$store.commit(\"edit\", 15); 当需要多参提交时，推荐把他们放在一个对象中来提交: 1this.$store.commit(\"edit\", &#123; age: 15, sex: \"男\" &#125;); 接收挂载的参数： 1234edit(state,payload)&#123; state.name = 'jack' console.log(payload) // 15或&#123;age:15,sex:'男'&#125;&#125; 另一种提交方式 1234567this.$store.commit(&#123; type: \"edit\", payload: &#123; age: 15, sex: \"男\", &#125;,&#125;); 增删 state 中的成员 为了配合 Vue 的响应式数据，我们在 Mutations 的方法中，应当使用 Vue 提供的方法来进行操作。如果使用 delete 或者 xx.xx = xx 的形式去删或增，则 Vue 不能对数据进行实时响应。 Vue.set 为某个对象设置成员的值，若不存在则新增 例如对 state 对象中添加一个 age 成员 1Vue.set(state, \"age\", 15); Vue.delete 删除成员 将刚刚添加的 age 成员删除 1Vue.delete(state, \"age\"); Getters可以对 state 中的成员加工后传递给外界 Getters 中的方法有两个默认参数 state 当前 Vuex 对象中的状态对象 getters当前 getters 对象，用于将 getters 下的其他 getter 拿来用 例如 12345678getters:&#123; nameInfo(state)&#123; return \"姓名:\"+state.name &#125;, fullInfo(state,getters)&#123; return getters.nameInfo+'年龄:'+state.age &#125;&#125; 组件中调用 1this.$store.getters.fullInfo; Actions由于直接在mutation方法中进行异步操作，将会引起数据失效。所以提供了Actions来专门进行异步操作，最终提交mutation方法。 Actions中的方法有两个默认参数 context 上下文(相当于箭头函数中的 this)对象 payload 挂载参数 例如，我们在两秒中后执行mutations传值中的 edit 方法 由于 setTimeout 是异步操作，所以需要使用 actions 1234567actions:&#123; aEdit(context,payload)&#123; setTimeout(()=&gt;&#123; context.commit('edit',payload) &#125;,2000) &#125;&#125; 在组件中调用: 1this.$store.dispatch(\"aEdit\", &#123; age: 15 &#125;); 改进: 由于是异步操作，所以我们可以为我们的异步操作封装为一个Promise对象 12345678 aEdit(context,payload)&#123; return new Promise((resolve,reject)=&gt;&#123; setTimeout(()=&gt;&#123; context.commit('edit',payload) resolve() &#125;,2000) &#125;)&#125; Models当项目庞大，状态非常多时，可以采用模块化管理模式。Vuex 允许我们将 store 分割成**模块(module)**。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割。 1234567models:&#123; a:&#123; state:&#123;&#125;, getters:&#123;&#125;, .... &#125;&#125; 组件内调用模块 a 的状态： 1this.$store.state.a; 而提交或者dispatch某个方法和以前一样,会自动执行所有模块内的对应type的方法： 12this.$store.commit(\"editKey\");this.$store.dispatch(\"aEditKey\"); 模块的细节 模块中mutations和getters中的方法接受的第一个参数是自身局部模块内部的state 1234567891011models:&#123; a:&#123; state:&#123;key:5&#125;, mutations:&#123; editKey(state)&#123; state.key = 9 &#125; &#125;, .... &#125;&#125; getters中方法的第三个参数是根节点状态 1234567891011models:&#123; a:&#123; state:&#123;key:5&#125;, getters:&#123; getKeyCount(state,getter,rootState)&#123; return rootState.key + state.key &#125; &#125;, .... &#125;&#125; actions 中方法获取局部模块状态是 context.state,根节点状态是 context.rootState 12345678910111213models:&#123; a:&#123; state:&#123;key:5&#125;, actions:&#123; aEidtKey(context)&#123; if(context.state.key === context.rootState.key)&#123; context.commit('editKey') &#125; &#125; &#125;, .... &#125;&#125; 规范目录结构如果把整个store都放在index.js中是不合理的，所以需要拆分。比较合适的目录格式如下： 123456789store:.│ actions.js│ getters.js│ index.js│ mutations.js│ mutations_type.js ##该项为存放mutaions方法常量的文件，按需要可加入│└─modules Astore.js 对应的内容存放在对应的文件中，和以前一样，在 index.js 中存放并导出 store。state 中的数据尽量放在 index.js 中。而 modules 中的 Astore 局部模块状态如果多的话也可以进行细分。 本文作者：人模人样的搬砖老段本文链接：关于 vuex如有错误，请及时评论或者知乎私信或者 B 站私信哦~","tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"Vuex","slug":"Vuex","permalink":"http://yoursite.com/tags/Vuex/"}]},{"title":"React的基本内容","date":"2020-02-23T04:04:16.000Z","path":"2020/02/23/React的基本内容/","text":"React 简介 声明式 (只需要告诉框架需要做什么，而不需要告诉他该怎么做，跟声明式对立的是命令式，比如 Jquery) 组件化 (Vue 中声明全局组件的方式 Vue.component 组件名 组件最大的好处是可以复用) 一次学习，随处编写 (React 可以写原生应用(ReactNative)和网页应用) React 分为五个部分 Jsx 语法 Component 组件 路由 状态管理 第三方工具 React 和 Vue 的不同 Vue 是官方维护的，而 React 是社区维护的 React 开发环境搭建 引用文件的方式基本使用 建立一个项目的目录进入项目 打开终端 npm init -y会在目录中产生一个 package.json 文件 npm I react –save 或 yarn add react(有 yarn 的)会在目录中产生项目依赖目录 node_modules进入 node_modules react umd 找到 react.development.js粘贴到项目目录下的 js 文件夹里 终端里 npm I react-dom –save 或 yarn add react-dom(有 yarn 的)进入 node-modules react-dom umd 找到 react-dom.development.js粘贴到项目目录下的 js 文件夹里创建 html 文件按顺序依次引入 react.development.js react-dom.development.js 文件 可以实现 hello word 的呈现ReactDOM.render(“hello world”,document.getElementById(“box”)) 此处只能渲染出来文本内容，渲染不出来带标签的内容，需要下载 babel 包 npm i babel-standalone 或 yarn add babel-standalone进入 node_modules babel-standalone复制 babel.js 粘贴到 js 文件夹里面再在 html 里面接着引入 如果使用了 babel.js 那么用 script 标签的时候就要加入 type=text/babel 就可以实现标签的呈现 在 html 文件中的引入顺序a react.development.jsb react-dom.development.jsc babel.js 注意这个问题script 的 type 属性指定为 text/babel babeles6 转为 es5解析 jsx 什么是 jsxjsx 是一种语法糖jsx 是 javascript 扩展的意思相当于 js+xmljsx 不是必须的，但是用 jsx 可以提高开发效率jsx 的原理就是 1React.creatElement(tag,&#123;attrs&#125;,content) react 的差值表达式是一对大括号 即为引用变量的写法 jsx 注意事项a 对象不能直接渲染,数组以字符串的形式进行渲染b 在 jsx 中 class 要改为 classNamec 事件的首字母要大写 如 onClick 形式d 写行内样式 1style&#x3D;&#123;&#123;color:&quot;red&quot;&#125;&#125; 第一对大括号表示差值表达式，第二对大括号表示差值表达式的值是一个对象 遍历列表 react 当中遍历列表要指定 key 值，可以使用 map 方法进行映射(也有其他方式) 遍历列表的时候注意标签的语义化 return 后面要有字符 react 特点 简洁 灵活 组件 无状态组件 123const 组件的名字&#x3D;(props)&#x3D;&gt;&#123; return jsx表达式&#125; 类组件 1234567class 组件的名字 extends React.Component&#123; render()&#123; &#x2F;&#x2F; this 常用的属性 state props refs &#x2F;&#x2F; state 是组件内部的数据 props 来自组件外部的数据 refs 标识一个组件的节点 return jsx表达式 &#125;&#125; 遍历对象遍历对象的关键就是把对象变成数组 1Object.keys(obj) 对象的浅拷贝，扩展运算符， Object.assign 12var obj &#x3D; &#123;...obj2&#125;var obj &#x3D; Object.assign(&#123;&#125;,obj2) jsx 中的注释 1&#123;&#x2F;*内容*&#x2F;&#125; refs 123&#x2F;&#x2F;this.refs.标识节点字符串&#x2F;&#x2F;&lt;node ref&#x3D;&#123;(标识节点的变量)&#x3D;&gt;this.自定义属性&#x3D;表示节点的变量&#125;&gt;&#x2F;&#x2F;this.自定义属性 就可以找到节点了 state 状态 存值 123456constructor(props)&#123; super(props); &#x2F;&#x2F; this.props有值 this.state&#x3D;&#123; key:value &#125;&#125; 更改 state 的值不能直接改 直接改就会视图不同步要改 state 用 setstate 更改 123this.setState(&#123; &#x2F;&#x2F;key: 新的value&#125;) setState 连续执行多次，对象会合并，只执行最后那一个 setState 的内容，跟前面的内容没有关系setState 是异步的操作，拿到最新的值要在回调函数里拿 计数器需求 : 计算点击按钮的次数 类组件 事件处理函数要绑定 this 或者用箭头函数建议尽量在构造函数 constructor 里绑定 this，因为这样只执行一次绑定 事件绑定处理函数，要进行传参this.方法名字.bind(this,参数)事件处理函数的最后一个参数是事件对象 setStatea) 异步b) 连续执行对象会合并 123this.setState(&#123; key:value&#125;,callback) c) 12345this.setState((prevState,props)&#x3D;&gt;&#123; return &#123; key:value &#125;&#125;,callback) 连续执行多次会放入队列中依次执行 组件挂载阶段，会自动执行的钩子函数constructorrendercomponentDidMount 受控组件与非受控组件表单元素他的值来自于 state 这个组件就是受控组件，否则就是非受控组件普通组件来说，它的数据都来自于外部 (props) 这个组件就是受控组件 类组件的三个属性state refs props 这三个是常用的 还有一个是 context 上下文 脚手架环境基本使用 字符串 includes 方法 判断是否含有子串(indexOf) dagerouslySetInnerHTML可以渲染 html 的字符串 1&lt;div dagerouslySetInnerHTML=&#123;&#123; __html: html的字符串 &#125;&#125;&gt;&lt;/div&gt; 脚手架环境安装 create-react-app #全局安装npm i create-react-app -gcreate-react-app –version #查看版本号 能看到版本号就说明安装成功了 创建项目:create-react-app 项目名字 src/index.js 就是入口文件 引入图片 12import 变量 from &#39;图片的路径&#39;&lt;img src&#x3D;&#123;变量&#125; &#x2F;&gt; 或 1&lt;img src&#x3D;&#123;require(&quot;图片的路径&quot;)&#125; &#x2F;&gt;&gt; 这种方法用于引入多张图片的时候，一张一张导入太麻烦 导入导出export xxx import {xxx} from 一次导入所有的import * as 名字 from 然后变量可取用名字.变量名 语法规则 jsx 的规则value 改为 defaultValuechecked 改为 defaultCheckedonXxxfor 改为 htmlForstyle 写对象class className{/注释/} ref 的第三种使用方式 (a,字符串的方式 b.回调函数的方式) 12345678createRefthis.state&#x3D;&#123; 变量:createRef()&#125;&lt;node ref&#x3D;&#123;this.state.变量&#125; &#x2F;&gt;引用这个节点 this.state.变量.current 就可以引用这个节点了 组件的传值父传子 通过属性传递子传父 调用父组件传递过来的方法 mock 数据工具 12npm i json-server -gjson-server --version 可以看到版本号就代表安装成功 建立一个 json 文件 1234567891011121314&#123; &quot;list&quot;:[ &#123; &quot;id&quot;:1, &quot;name&quot;:&quot;zhangsan&quot;, &quot;age&quot;:20 &#125;, &#123; &quot;id&quot;:2, &quot;name&quot;:&quot;lisi&quot;, &quot;age&quot;:25 &#125; ]&#125; 在这个文件处打开终端，执行下面的命令，就能把这个文件在指定的端口运行起来json-server xxx.json –port 端口号json-server 模糊查找有两种形式全局查找url?q=查找的关键字以某一个字段进行模糊查找，比如年龄包含 2 的url?age_like=2 本文作者：人模人样的搬砖老段本文链接：React 的基本内容如有错误，请及时评论或者知乎私信或者 B 站私信哦~","tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"小程序开发中需要注意的一些内容","date":"2020-02-09T11:03:51.000Z","path":"2020/02/09/小程序开发中需要注意的一些内容/","text":"主要用于记录在 小程序 项目开发中踩过的坑，或者没有了解过的东西(持续更新)前端学无止境 ヾ(ﾟ ∀ ﾟゞ)秃头从未停止 ヾ(ﾟ ∀ ﾟゞ) 真就基本上看着官方文档做开发呗文档真香 小程序中的支付流程虽然都是有现成接口直接调用就完事儿了，但是整个支付流程的实现我还是要整理一下的 如果要做支付，首先要判断用户的登录状态，没有登录的话让用户登录，用 wx.login 获取到 code 值，带上 appid 和 appsecret，去获取到用户的唯一标识 openid，这样用户就处于登录状态了，然后在登录状态下首先要生成订单，如果有需要的话，确认商品价钱和名称，然后调用后台支付接口，传入 openid，成功的话会获取到订单的所有信息，保存所需信息，就可以发起支付了，支付的话直接调用小程序支付 api，传入所需参数，成功的话返回上一页显示支付成功信息。 具体代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697var app = getApp();Page(&#123; data: &#123;&#125;, onLoad: function (options) &#123; // 页面初始化 options为页面跳转所带来的参数 var that = this //登陆获取code wx.login(&#123; success: function (res) &#123; console.log(res.code) //获取openid that.getOpenId(res.code) &#125; &#125;); &#125;, getOpenId: function (code) &#123; var that = this; wx.request(&#123; url: \"https://api.weixin.qq.com/sns/jscode2session?appid=小程序appid&amp;secret=小程序应用密钥&amp;js_code=\" + code + \"&amp;grant_type=authorization_code\", data: &#123;&#125;, method: 'GET', success: function (res) &#123; that.generateOrder(res.data.openid) &#125;, fail: function () &#123; // fail &#125;, complete: function () &#123; // complete &#125; &#125;) &#125;, /**生成商户订单 */ generateOrder: function (openid) &#123; var that = this //统一支付 wx.request(&#123; url: '后台路径', method: 'GET', data: &#123; gfee: '商品价钱', gname: '商品名称', openId:openid （商品价钱和商品名称根据自身需要是否传值,openid为必传） &#125;, success: function (res) &#123; var pay = res.data //发起支付 var timeStamp = pay[0].timeStamp; var packages = pay[0].package; var paySign = pay[0].paySign; var nonceStr = pay[0].nonceStr; var param = &#123; \"timeStamp\": timeStamp, \"package\": packages, \"paySign\": paySign, \"signType\": \"MD5\", \"nonceStr\": nonceStr &#125;; that.pay(param) &#125;, &#125;) &#125;, /* 支付 */ pay: function (param) &#123; console.log(\"支付\") console.log(param) wx.requestPayment(&#123; timeStamp: param.timeStamp, nonceStr: param.nonceStr, package: param.package, signType: param.signType, paySign: param.paySign, success: function (res) &#123; // success wx.navigateBack(&#123; delta: 1, // 回退前 delta(默认为1) 页面 success: function (res) &#123; wx.showToast(&#123; title: '支付成功', icon: 'success', duration: 2000 &#125;) &#125;, fail: function () &#123; // fail &#125;, complete: function () &#123; // complete &#125; &#125;) &#125;, fail: function (res) &#123; // fail &#125;, complete: function () &#123; // complete &#125; &#125;) &#125;&#125;) 本文作者:人模人样的搬砖老段本文链接:小程序开发中需要注意的一些内容如有错误，请及时评论或者知乎私信或者 B 站私信哦~","tags":[{"name":"项目开发","slug":"项目开发","permalink":"http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"},{"name":"注意点","slug":"注意点","permalink":"http://yoursite.com/tags/%E6%B3%A8%E6%84%8F%E7%82%B9/"},{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"},{"name":"小程序","slug":"小程序","permalink":"http://yoursite.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"vue开发中需要注意的一些内容","date":"2020-01-26T09:03:33.000Z","path":"2020/01/26/vue开发中需要注意的一些内容/","text":"主要用于记录在 Vue 项目开发中踩过的坑，或者没有了解过的东西(持续更新)前端学无止境 ヾ(ﾟ ∀ ﾟゞ)秃头从未停止 ヾ(ﾟ ∀ ﾟゞ) v-if 和 v-show 要学会区分开使用区别 手段：v-if 是通过控制 dom 节点的存在与否来控制元素的显隐;v-show 是通过设置 DOM 元素的 display 样式，block 为显示，none 为隐藏; 编译过程：v-if 切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件;v-show 只是简单的基于 css 切换; 编译条件：v-if 是惰性的，如果初始条件为假，则什么也不做;只有在条件第一次变为真时才开始局部编译（编译被缓存?编译被缓存后，然后再切换的时候进行局部卸载); v-show 是在任何条件下（首次条件是否为真）都被编译，然后被缓存，而且 DOM 元素保留; 性能消耗：v-if 有更高的切换消耗;v-show 有更高的初始渲染消耗; 使用场景 基于以上区别，因此，如果需要非常频繁地切换，则使用 v-show 较好;如果在运行时条件很少改变，则使用 v-if 较好。 总结 v-if 判断是否加载，可以减轻服务器的压力，在需要时加载,但有更高的切换开销;v-show 调整 DOM 元素的 CSS 的 dispaly 属性，可以使客户端操作更加流畅，但有更高的初始渲染开销。如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。 页面内监听 scroll 事件的方法如果是整个网页可以滑动，可以使用以下事件监听 123window.addEventListener(\"scroll\", function () &#123; console.log(\"scrolling\");&#125;); 但是大部分的场景是在一个元素内发生页面滚动 举例：在页面内的一个div需要监听的 滑动的组件外层的div加 ref=&quot;viewBox&quot; 为了通过$refs获取dom元素 12345678910111213&lt;!--设备列表--&gt;&lt;div class=\"deviceWrapper\" ref=\"viewBox\"&gt; &lt;mu-refresh-control :refreshing=\"refreshing\" :trigger=\"trigger\" @refresh=\"refresh\"/&gt; &lt;div class=\"demo-grid\"&gt; &lt;!--设备列表 手机一行两列 pad一行4列--&gt; &lt;mu-row&gt; &lt;mu-col v-for=\"device in devicesList\" width=\"50\" tablet=\"25\" desktop=\"25\"&gt; &lt;deviceCardView :device-data=\"device\"\"&gt;&lt;/devicelightCardView&gt; &lt;/mu-col&gt; &lt;/mu-row&gt; &lt;/div&gt; &lt;p class=\"bottomLine\" v-bind:class=\"&#123;bottomLineVisible:isScroll&#125;\"&gt;---------------------我是有底线的---------------------&lt;/p&gt;&lt;/div&gt; 获取元素，监听事件 12345678910mounted() &#123;// 通过$refs获取dom元素 this.box = this.$refs.viewBox // 监听这个dom的scroll事件 this.box.addEventListener('scroll', () =&gt; &#123; console.log(\" scroll \" + this.$refs.viewBox.scrollTop) //以下是我自己的需求，向下滚动的时候显示“我是有底线的（类似支付宝）” this.isScroll=this.$refs.viewBox.scrollTop&gt;0 &#125;, false)&#125; 这样能正常打印出来.scrollTop 封装一个组件，用于段落文字点击展开和收起功能组件调用方法 1234&lt;Unfold data=\"这里是文章测试标题，含标点一共二十个字。这里是文章测试标题，含标点一共二十个字。这里是文章测试标题，含标点一共二十个字。这里是文章测试标题，含标点一共二十个字。这里是文章测试标题，含标点一共二十个字。这里是文章测试标题，含标点一共二十个字。这里是文章测试标题，含标点一共二十个字。这里是文章测试标题，含标点一共二十个字。\" maxLength=\"100\"/&gt; 属性说明 data：文字数据maxLen：最大长度，超过这个数，被截取，默认 80，不改长度无需传值 封装好组件的完整代码 需要此功能的地方直接调用这个组件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;template&gt; &lt;span&gt; &lt;span v-if&#x3D;&quot;data.length &lt; maxLen&quot;&gt; &lt;span class&#x3D;&quot;tj&quot;&gt;&#123;&#123; data &#125;&#125;&lt;&#x2F;span&gt; &lt;&#x2F;span&gt; &lt;span v-else&gt; &lt;span class&#x3D;&quot;tj&quot; &gt;&#123;&#123; showBtn ? sliceStr : data &#125;&#125; &lt;span class&#x3D;&quot;btnWord&quot; @click&#x3D;&quot;showBtn &#x3D; !showBtn&quot;&gt;&#123;&#123; showBtn ? &quot;全文&quot; : &quot;收起&quot; &#125;&#125;&lt;&#x2F;span&gt; &lt;&#x2F;span&gt; &lt;&#x2F;span&gt; &lt;&#x2F;span&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; name: &quot;unfold&quot;, data() &#123; return &#123; showBtn: true, &#125;; &#125;, props: &#123; &#x2F;&#x2F; 数据 data: &#123; type: String, default: &quot;&quot;, &#125;, &#x2F;&#x2F; 最大长度 maxLen: &#123; type: Number, default: 80, &#125;, &#125;, computed: &#123; sliceStr() &#123; if (this.data !&#x3D; null) &#123; return this.data.substring(0, this.maxLen) + &quot;...&quot;; &#125; return &quot;&quot;; &#125;, &#125;,&#125;;&lt;&#x2F;script&gt;&lt;style lang&#x3D;&quot;less&quot; scoped&gt;.tj &#123; text-align: justify;&#125;.btnWord &#123; color: cornflowerblue; cursor: pointer; word-break: keep-all;&#125;&lt;&#x2F;style&gt; 封装一个功能：移动端 home 键单击返回上一页，双击退出应用js 文件，如 back.js 123456789101112document.addEventListener(\"plusready\", function () &#123; var webview = plus.webview.currentWebview(); plus.key.addEventListener(\"backbutton\", function () &#123; webview.canBack(function (e) &#123; if (e.canBack) &#123; webview.back(-1); //返回上一页 &#125; else &#123; webview.close(); //关闭应用 &#125; &#125;); &#125;);&#125;); main.js 中引入这个 js 文件并使用 123456789import Back from \"../src/helper/back\";new Vue(&#123; el: \"#app\", router, Back, components: &#123; App &#125;, template: \"&lt;App/&gt;\",&#125;); 关于电商项目中的购物车单选全选计算总价的实现最开始是参考了一篇文章，后来就组件复用(太长了懒得写了)参考的文章:vue 实现购物车单选全选计算总价功能 在 React 项目中也是参考了其实现原理进行功能模块的封装 本文作者:人模人样的搬砖老段本文链接:vue 开发中需要注意的一些内容如有错误，请及时评论或者知乎私信或者 B 站私信哦~","tags":[{"name":"项目开发","slug":"项目开发","permalink":"http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"},{"name":"注意点","slug":"注意点","permalink":"http://yoursite.com/tags/%E6%B3%A8%E6%84%8F%E7%82%B9/"},{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"},{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"Vue之写一个简单的Todolist","date":"2020-01-12T06:20:52.000Z","path":"2020/01/12/Vue之写一个简单的Todolist/","text":"Todolist待办事项。效果参考网址vue-todolist示例效果中用的是 localStorage 本地存储，所以直接定义了空数组，利用数组的方式。 本文作者：人模人样的搬砖老段本文链接：Vue 之写一个简单的 Todolist如有错误，请及时评论或者知乎私信或者 B 站私信哦~","tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"Vue的一些基本内容","date":"2019-12-29T11:00:26.000Z","path":"2019/12/29/Vue的一些基本内容/","text":"Vue.jsVue.js 是一款渐进式 Javascript 框架，什么是渐进式？就是我们可以由浅入深的，由简单到复杂的，去使用 Vue.js Vue.js 的优点 体积小压缩后的 Vue.js 只有 33K 更高的运行效率Vue.js 基于虚拟 Dom，是一种可以预先通过 Javascript 进行各种计算，把最终的 Dom 操作计算出来并优化的技术，由于这个 Dom 操作属于预处理操作，并没有真实的操作 Dom，所以叫做虚拟 Dom。 实现了双向数据绑定双向数据绑定让开发者不用再去操作 Dom 对象，把更多的精力投入到业务逻辑上。 生态丰富、学习成本低市场上拥有大量成熟、稳定的基于 Vue.js 的 ui 框架、常用组件！拿来即用就可以实现快速开发。 Vue.js 的安装 可以直接使用 “script” 标签引入，Vue 会被注册为一个全局变量。对于初学者来说，还是使用第一种方法较好 开发的时候，在官网下载开发版本，会直接下载下来一个 Vue.js 的文件，引入到我们的项目中，用 script 标签引入即可。如果将来学会了 Vue 的单文件组件的应用，可以创建一个.vue 结尾的文件。 或者使用 CDN 的方式，用 script 标签引入一个 CDN 链接 可以使用命令行工具 CLI，去快速搭建一个脚手架。建议:当我们对 Vue 有了一定的了解之后，再使用第二种方式 创建第一个 Vue.js 的应用Vue.js 的核心是个允许采用简洁的模板语法来声明式地将数据渲染进 Dom 的系统 Vue.js 应用主要分为两个部分: 一为视图，即为 HTML 代码。 123&lt;div id=\"app\"&gt; &#123;&#123;message&#125;&#125; &#123;&#123;name&#125;&#125;&lt;/div&gt; 一为脚本，即为 js 代码 12345678910//通过 new Vue 的方式可以获得一个Vue的应用//app即为一个对象，或者称为Vue.js的对象var app = new Vue(&#123; el: \"#app\", // el即为element,代表元素 data: &#123; // data 用于保存数据 我们在视图中声明了哪些变量，就需要在data里面注册这些变量，并且为这些变量进行初始化的赋值。 message: \"Hey Girl!\", name: \"Vue\", &#125;,&#125;); Vue 实例每一个 Vue 应用其实都是通过 Vue 函数创建一个新的实例开始的 123var vm = new Vue(&#123; // 选项&#125;); Vue 虽然没有完全遵循 MVVM 模型，但是 Vue 的设计也受到了它的启发，因此在文档中经常会使用 vm 未完待续….. 本文作者：人模人样的搬砖老段本文链接：Vue 的一些基本内容如有错误，请及时评论或者知乎私信或者 B 站私信哦~","tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"关于闭包","date":"2019-12-15T14:44:00.000Z","path":"2019/12/15/关于闭包/","text":"什么是闭包闭包就是能够读取其他函数内部变量的函数。在 JS 中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解为”定义在一个函数内部的函数”。 1234567891011121314151617181920function fn() &#123; var b = 1; //闭包 function box() &#123; // console.log(b); &#125; //返回一个函数，这个函数就是一个闭包 return box;&#125;//res 就是 box 函数var res = fn();//2秒以后调用res函数，还是能打印b的值,闭包能让局部变量常驻内存setTimeout(function () &#123; res();&#125;, 2000); 闭包的特点 可以读取函数内部的变量。变量的作用域无非就是两种：全局变量和局部变量。JS 语言的特殊之处，就在于函数内部可以直接读取全局变量。另一方面，函数外部自然无法读取函数内的局部变量。 让这些变量的值始终保存在内存中。 闭包的应用场景 函数作为返回值。 1234567891011121314function box() &#123; var n = 1; // function cox() &#123; n++; return n; &#125; return cox;&#125;//res 就是一个闭包 ，n像是一个全局变量var res = box();console.log(res()); //2console.log(res()); //3 函数作为参数被传递回调函数 闭包深度解析参考阮一峰博客：学习 Javascript 闭包（Closure） 本文作者:人模人样的搬砖老段本文链接:关于闭包如有错误，请及时评论或者知乎私信或者 B 站私信哦~","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"闭包","slug":"闭包","permalink":"http://yoursite.com/tags/%E9%97%AD%E5%8C%85/"}]},{"title":"jQuery一些基本内容(二)","date":"2019-12-01T12:28:13.000Z","path":"2019/12/01/jQuery一些基本内容-二/","text":"过滤元素eq(index|-index):参数可以为正值也可以为负值，获取第 N 个元素，这个元素的位置从 0 开始，如果是负数，则从集合中的最后一个元素开始倒数，参数为-1 就是最后一个元素，-2 就是倒数第二个元素。first():获取第一个元素。last():获取最后一个元素。 1234$(&#39;ul li).eq(-2).css(&#123;background:&#39;red&#39;&#125;);$(&#39;ul li).first().css(&#123;background:&#39;red&#39;&#125;);$(&#39;ul li).last().css(&#123;background:&#39;red&#39;&#125;);&#x2F;&#x2F;过滤之后得出的仍然是个伪数组，所以可以继续调用jq中的方法 children([expr]):不传参数是匹配所有子元素，传入参数是匹配其子元素中符合条件的所有子元素。 123456&lt;p&gt;Hello&lt;&#x2F;p&gt;&lt;div&gt;&lt;span&gt;Hello Again&lt;&#x2F;span&gt;&lt;p class&#x3D;&quot;selected&quot;&gt;aaa&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;&lt;p&gt;And Again&lt;&#x2F;p&gt;&#x2F;&#x2F;查找类名为div中的每个子元素$(&#39;div&#39;).children()&#x2F;&#x2F;在每个div中查找class名为selected的元素$(&#39;div&#39;).children(&#39;.selected&#39;) parent([expr]):取得一个包含着所有匹配元素的位以父元素的元素集合（匹配父元素，返回的是伪数组）(直接父元素) 123456&lt;div&gt;&lt;p&gt;Hello&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;&lt;div class&#x3D;&quot;selected&quot;&gt;&lt;p&gt;Hello&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;&#x2F;&#x2F;查询p元素的直接父元素$(&#39;p&#39;).parent()&#x2F;&#x2F;查询p元素的直接父元素中带有这个class名的元素$(&#39;p&#39;).parent(&#39;.selected&#39;) find(expr):搜索所有与指定表达式匹配的后代元素，相当于$(‘ul li’) 123&lt;p&gt;&lt;span&gt;Hello&lt;&#x2F;span&gt;,how are you?&lt;&#x2F;p&gt;&#x2F;&#x2F;查找所有p元素下的span元素，与$(&#39;p span&#39;)相同$(&#39;p&#39;).find(&#39;span&#39;) next([expr]):取得一个包含匹配的元素集合中每一个元素紧邻的后面同辈元素的元素集合。 123456&lt;p&gt;Hello&lt;&#x2F;p&gt;&lt;p class&#x3D;&quot;selected&quot;&gt;Hello Again&lt;&#x2F;p&gt;&lt;div&gt;&lt;span&gt;And Again&lt;&#x2F;span&gt;&lt;&#x2F;div&gt;&#x2F;&#x2F;找到每个段落后面的近邻的同辈元素$(&#39;p&#39;).next()&#x2F;&#x2F;找到每个段落的后面**紧邻**的同辈元素中类名为selected的元素$(&#39;p&#39;).next(&#39;selected&#39;) nextAll([expr]):查找当前元素之后所有的同辈元素 12345&lt;div&gt;&lt;&#x2F;div&gt;&lt;div&gt;&lt;&#x2F;div&gt;&lt;div&gt;&lt;&#x2F;div&gt;&#x2F;&#x2F;给第一个div元素之后的所有同辈元素都添加一个class名$(&#39;div:first&#39;).nextAll().addClass(&#39;after&#39;);&lt;div&gt;&lt;&#x2F;div&gt;&lt;div class&#x3D;&quot;after&quot;&gt;&lt;&#x2F;div&gt;&lt;div class&#x3D;&quot;after&quot;&gt;&lt;&#x2F;div&gt; prev([expr]):取得一个包含匹配的元素集合中每一个元素近邻的前一个同辈元素的集合。(紧邻的前一个元素) prevAll([expr]):查找当前元素之前所有的同辈元素。 siblings([expr]):取得一个包含匹配的元素集合中每一个元素的所有唯一同辈元素的元素集合。可以用可选的表达式进行筛选。 1234567&lt;p&gt;Hello&lt;&#x2F;p&gt;&lt;div&gt;&lt;span&gt;Hello Again&lt;&#x2F;span&gt;&lt;&#x2F;div&gt;&lt;p&gt;And Again&lt;&#x2F;p&gt;&#x2F;&#x2F;找到每个div的所有同辈元素$(&#39;div&#39;).siblings()&lt;div&gt;&lt;span&gt;Hello&lt;&#x2F;span&gt;&lt;&#x2F;div&gt;&lt;p class&#x3D;&quot;selected&quot;&gt;Hello Again&lt;&#x2F;p&gt;&lt;p&gt;And Again&lt;&#x2F;p&gt;&#x2F;&#x2F;找到每个div的所有同辈元素中带有类名为selected的元素$(&#39;div&#39;).siblings(&#39;.selected&#39;) end():回到最近的一个“破坏性操作之前”。破坏性操作即为有变化。 123&lt;p&gt;&lt;span&gt;Hello&lt;&#x2F;span&gt;,how are you?&lt;&#x2F;p&gt;&#x2F;&#x2F;选取所有的p元素，查找并选取span子元素，然后再回过来选取p元素$(&#39;p&#39;).find(&#39;span&#39;).end() 遍历each(callback):以每一个匹配的元素来作为上下文来执行一个函数。回调函数有两个参数，第一个参数代表索引，第二个参数代表当前遍历到的 DO 对象 123$(&#39;#box li&#39;).each(function(index,val)&#123; console.log(index,val)&#x2F;&#x2F;index是下标，val是下标对应的原生dom元素&#125;) index([selector|element]):搜索屁屁额的元素，并返回相应元素的索引值，从 0 开始计数。如果参数是一组 DOM 元素或者 jQuery 对象，那么返回值就是传递的元素相当于原先集合的位置，如果不传递参数，那么返回值就是这个 jQuery 对象集合中第一个元素相对于其同辈元素的位置。 1234567891011121314151617181920212223&lt;ul&gt; &lt;li&gt;item1&lt;&#x2F;li&gt; &lt;li id&#x3D;&quot;one&quot;&gt;item2&lt;&#x2F;li&gt; &lt;li class&#x3D;&quot;one&quot;&gt;item3&lt;&#x2F;li&gt; &lt;li class&#x3D;&quot;selected&quot;&gt;item4&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;$(&#39;li&#39;).click(function name(params) &#123; console.log($(this).index()); &#x2F;&#x2F;此处的index拿到的是被点击的该元素的同辈元素的下标 console.log($(this).index(&#39;li&#39;)); &#x2F;&#x2F;与上面的效果相同&#125;)console.log($(&#39;li&#39;).index(document.getElementsByClassName(&#39;selected&#39;)[0])); &#x2F;&#x2F;返回的是这个Dom对象在原先的li集合中的索引位置console.log($(&#39;li&#39;).index($(&#39;#one&#39;))); &#x2F;&#x2F;返回的是这个jQuery对象在li集合中的下标console.log($(&#39;#one&#39;).index(&#39;li&#39;)); &#x2F;&#x2F; 传递的是一个选择器，返回id为one的jQuery对象在所有li中的索引位置console.log($(&#39;.selected&#39;).index()); &#x2F;&#x2F; 不传递参数，返回的是这个元素在同辈元素中的索引位置 DOM 操作创建1$(&#39;&lt;div&gt;&lt;&#x2F;div&gt;&#39;) 内部插入操作append(content)：向每个匹配的元素内部追加内容。 12$(&quot;p&quot;).append(&quot;&lt;b&gt;Hello&lt;&#x2F;b&gt;&quot;);&#x2F;&#x2F;头部添加 prepend(content)：向每个匹配的元素内部前置内容。 12$(&quot;p&quot;).prepend(&quot;&lt;b&gt;Hello&lt;&#x2F;b&gt;&quot;);&#x2F;&#x2F;尾部添加 appendTo(content):把所有匹配的元素追加到另一个指定的元素元素集合中。 123&lt;div&gt;&lt;&#x2F;div&gt;&lt;div&gt;&lt;&#x2F;div&gt;&#x2F;&#x2F;新建段落追加到每一个div中 尾部追加$(&quot;&lt;p&#x2F;&gt;&quot;).appendTo(&quot;div&quot;) 外部插入操作after(content)：在每个匹配的元素之后插入内容。 1$(&quot;p&quot;).after(&quot;&lt;b&gt;Hello&lt;&#x2F;b&gt;&quot;); before(content)：在每个匹配的元素之前插入内容。 1$(&quot;p&quot;).before(&quot;&lt;b&gt;Hello&lt;&#x2F;b&gt;&quot;); 替换操作replaceWith(content)：将所有匹配的元素替换成指定的 HTML 或 DOM 元素。 12$(&quot;p&quot;).replaceWith(&quot;&lt;h2&gt;888&lt;&#x2F;h2&gt;&quot;);&#x2F;&#x2F;把所有的段落标记替换成标题。 删除操作empty()：删除匹配的元素集合中所有的子节点。 12&lt;p&gt;Hello,&lt;span&gt;Person&lt;&#x2F;span&gt; &lt;a href&#x3D;&quot;#&quot;&gt;and person&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;$(&quot;p&quot;).empty(); remove([expr])：从 DOM 中删除所有匹配的元素。 123$(&quot;p&quot;).remove();&#x2F;&#x2F;从DOM中把带有hello类的段落删除$(&quot;p&quot;).remove(&quot;.hello&quot;); 复制操作clone(Even])：克隆匹配的 DOM 元素并且选中这些克隆的副本。even：一个布尔值（true 或者 false）指示事件处理函数是否会被复制。 12&lt;b&gt;Hello&lt;&#x2F;b&gt;&lt;p&gt;, how are you?&lt;&#x2F;p&gt;$(&quot;b&quot;).clone().prependTo(&quot;p&quot;); 事件页面载入事件：ready(fn)：当 DOM 载入就绪可以查询及操纵时绑定一个要执行的函数。这是事件模块中最重要的一个函数，因为它可以极大地提高 web 应用程序的响应速度。简单地说，这个方法纯粹是对向 window.onload 事件注册事件的替代方法。绑定事件：bind(type,fn)：为每个匹配元素的特定事件绑定事件处理函数。unbind(type,[fn]])：bind()的反向操作，从每一个匹配的元素中删除绑定的事件。如果没有参数，则删除所有绑定的事件。hover([over,]out)：当鼠标移动到一个匹配的元素上面时，会触发指定的第一个函数。当鼠标移出这个元素时，会触发指定的第二个函数。click(fn)：触发每一个匹配元素的 click 事件。这个函数会调用执行绑定到 click 事件的所有函数。注：其他事件方法使用方式一样。例如：mouseover、mouseout、dblclick、change、blur、focus、keydown、keyup、keypress、mousedown、mouseup、mousemove、mouseenter、mouseleave、resize、scroll、select、submit、unload 等。on(event,[selector],fn)：在选择元素上绑定一个事件的事件处理函数。 12345678&#x2F;&#x2F;直接给p绑定事件$(&quot;p&quot;).on(&quot;click&quot;, function()&#123; alert( $(this).text() );&#125;);&#x2F;&#x2F;如果第二个参数传入一个选择器，就是监听父元素中li的点击事件，相当于 事件委托！$(&#39;ul&#39;).on(&#39;click&#39;,&#39;li&#39;,function()&#123; console.log(11) &#125;) off(event,[selector],[fn])：在选择元素上移除一个事件的事件处理函数 AjaxjQuery.ajax(settings)：通过 HTTP 请求加载远程数据，返回其创建的 XHR 对象。Settings:async：Boolean 类型。默认为 true（异步）。contentType：string 类型。默认为 application/x-www-form-urlencoded，发送信息至服务器时内容编码类型。timeout：设置请求超时时间（毫秒）。type：请求方式（GET 或 POST），默认为 GET。url：默认当前页地址，发送请求的地址。data：object/string 类型。发送到服务器的数据。error：在请求出错时调用。传入 XHR 对象，描述错误类型的字符串success：当请求成功之后调用，传入返回后的数据，以及包含成功代码的字符串。 Get 请求123456789101112var url &#x3D; &#39;https:&#x2F;&#x2F;api.readhub.me&#x2F;topic?lastCursor&#x3D;7544&amp;pageSize&#x3D;10&#39;$.ajax(&#123; url:url, type:&#39;get&#39;, success:function (res) &#123; console.log(res) &#125;, error:function (error) &#123; console.log(error); &#125; &#125;) Get 请求 212345678910111213var data &#x3D; &#123;lastCursor:7544,pageSize:10&#125; var url &#x3D; &#39;https:&#x2F;&#x2F;api.readhub.me&#x2F;topic&#39; $.ajax(&#123; url:url, type:&#39;get&#39;, data:data ,&#x2F;&#x2F;设置参数 success:function (res) &#123; console.log(res) &#125;, error:function (error) &#123; console.log(error); &#125; &#125;);; post 请求123456789101112131415var data &#x3D; &#123;lastCursor:7544,pageSize:10&#125; var url &#x3D; &#39;https:&#x2F;&#x2F;api.readhub.me&#x2F;topic&#39; $.ajax(&#123; url:url, type:&#39;post&#39;, data:data ,&#x2F;&#x2F;设置参数 success:function (res) &#123; console.log(res); &#125;, error:function (error) &#123; console.log(error); &#125; &#125;); jsonP 请求1234567891011121314var url1 &#x3D; &#39;https:&#x2F;&#x2F;sp0.baidu.com&#x2F;5a1Fazu8AA54nxGko9WTAnF6hhy&#x2F;su?wd&#x3D;n&#39; &#x2F;&#x2F;jsonp 接口 必须 两个字段 dataType:&#39;jsonp&#39;， jsonp:cb（回调函数字段）&#x2F;&#x2F;jq会自动生成回调函数 &#x2F;&#x2F;&amp;cb&#x3D;jQuery1102045621865612995216_1498111113677 $.ajax(&#123; url:url1, dataType:&#39;jsonp&#39;, jsonp:&#39;cb&#39;, success:function (res) &#123; console.log(res) &#125;, error:function (error) &#123; console.log(error) &#125; &#125;) 快捷请求函数$.getJSON(url, [data], [callback])：通过 HTTP GET 请求获取 JSON 数据。 12345var data &#x3D; &#123;lastCursor:7544,pageSize:10&#125; var url &#x3D; &#39;https:&#x2F;&#x2F;api.readhub.me&#x2F;topic&#39; $.getJSON(url,data,function (res) &#123; console.log(res); &#125;) 也可以通过使用 JSONP 形式的回调函数来加载其他网站的数据。如：”myulr?cb=?”，jQuery 会自动替换 ? 为正确的函数名，以执行回调函数。 1234&#x2F;&#x2F;jsonp 请求 ，注意cb&#x3D;？，？号，jq会自动生成回调函数 $.getJSON(&#39;https:&#x2F;&#x2F;sp0.baidu.com&#x2F;5a1Fazu8AA54nxGko9WTAnF6hhy&#x2F;su?wd&#x3D;n&amp;cb&#x3D;?&#39;,function (res) &#123; console.log(res,&#39;jsonp&#39;); &#125;) jQuery 插件参考网址jQuery 之家http://www.htmleaf.com/jQuery 插件库https://www.jq22.com/ 本文作者：人模人样的搬砖老段本文链接：jQuery 的一些基本内容（二）如有错误，请及时评论或者知乎私信或者 B 站私信哦~","tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"}]},{"title":"jQuery一些基本内容(一)","date":"2019-11-17T09:40:31.000Z","path":"2019/11/17/jQuery一些基本内容-一/","text":"什么是 jQuery jQuery 是一个兼容多浏览器的 js 库，核心理念是”write less,do more”j 代表 javascript,Query 就是查询的意思，这样理解来也通俗易懂，jQuery 是免费并且开源的。它可以简化查询 DOM 对象，处理事件，制作动画，处理 Ajax 交互过程。 简单来说，就是当初的原生 js 并不太好用，就有程序员把原生 js 封装了一下，就有了 jQuery。所以 jQuery 中的大部分语法都可以参照原生 JS，就是用了一些封装的方法实现了一些原生 JS 中比较复杂的功能。现在 jQuery 的流行程度已经大不如前，部分网站还在使用一些老版本的 jQuery 库还是因为老版本的 jQuery 兼容低版本的 ie 浏览其更加方便，jQuery 的官网已经更新到了 3.4 多的版本，现版本的 jQuery 已经完全不兼容低版本的 ie 浏览器了。 jQuery 的使用 使用 jQuery 的话，引入就可以了，可以下载官方文档，也可以直接引入接口 123&lt;script src&#x3D;&quot;jquery-1.11.3.min.js&quot; type&#x3D;&quot;text&#x2F;javascript&quot; charset&#x3D;&quot;utf-8&quot;&gt;&lt;&#x2F;script&gt;#或者 &lt;script src&#x3D;&quot;http:&#x2F;&#x2F;libs.baidu.com&#x2F;jquery&#x2F;2.0.0&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt; 引入官方文档的话，最好引入压缩过的，例如带 min 后缀的，一是文件更小，加载快，一是代码经过加密。(都开源了，加密不加密没区别吧。。) jQuery 选择器 选择器是 jQuery 最核心的内容，大大简化了对 DOM 的查询操作。css1-css3 的选择器都可以当做$函数的参数。 123456$(&#39;#box&#39;) # ID选择器$(&#39;.box&#39;) # 类名选择器$(&#39;div&#39;) # 标签选择器$(&#39;*&#39;) # 通配符选择器$(&#39;div,p,a&#39;) # 群组选择器$(&#39;#box p&#39;) # 后代选择器 此处的$在jQuery的官方文档中就是封装的jQuery函数，即为把$替换成 jQuery 的作用是相同的，但是$写起来更加方便。$函数的作用在原生 JS 中就相当于是 document.querySlectorAll()所以$函数返回的一直是一个数组。通过下标可以获得其中的元素。可以通过打印来对比： 12console.log($(&#39;#box&#39;));console.log($(&#39;#box&#39;)[0]); jQuery 操作 DOM 属性 操作属性设置被选中元素的属性值 1$(&#39;.box&#39;).attr(&#39;name&#39;,&#39;test1&#39;) #为类名为box的全部元素设置name属性，属性值为test1 返回被选中元素的属性值 1$(&#39;.box&#39;).attr(&#39;name&#39;) #返回第一个类名为box的元素的name属性的值 此处设置属性的值是为所有元素设置，而获取只能获取到第一个元素的。从所有匹配到的元素中删除该属性 1$(&#39;.box&#39;).removeAttr(&#39;name&#39;) #删除类名为box的所有元素的name属性 操作 class操作类名： 12345$(&#39;.box&#39;).addClass(&#39;item&#39;) # 为所有匹配到的元素添加指定的class名$(&#39;.box&#39;).removeClass(&#39;item&#39;) # 从所有匹配到的元素中删除指定的class名$(&#39;.box&#39;).toggleClass(&#39;item&#39;) # 如果存在就删除，如果不存在就添加 多次添加 class 名不会覆盖，而是会累加，同名的不会累加 操作 cssjQuery 中的方法： 123$(&#39;.box&#39;).css(&#39;width&#39;,100) # 将类名为box的所有元素的宽度设置为100$(&#39;.box&#39;).css(&#39;width&#39;) # 获取第一个类名为box的元素的宽度的值 操作内容jQuery 中的方法： 12345678$(&#39;.box&#39;).html() # 获取元素的html内容$(&#39;.box&#39;).html(&#39;aaa&#39;) # 设置元素的html内容$(&#39;.box&#39;).text() # 获取元素的text内容$(&#39;.box&#39;).text(&#39;aaa&#39;) # 设置元素的text内容$(&#39;.box&#39;).val() # 获取输入框的内容$(&#39;.box&#39;).val(&#39;aaa&#39;) # 设置输入框的内容 操作尺寸jQuery 中的方法： 1$(&#39;.box&#39;). height([val])：取得匹配元素当前计算的高度值（px）。width([val])：取得第一个匹配元素当前计算的宽度值（px）。innerHeight()：获取第一个匹配元素内部区域高度（包括补白、不包括边框）。此方法对可见和隐藏元素均有效。innerWidth()：获取第一个匹配元素内部区域宽度（包括补白、不包括边框）。此方法对可见和隐藏元素均有效。outerHeight()：获取第一个匹配元素外部高度（默认包括补白和边框）。此方法对可见和隐藏元素均有效。outerWidth()：获取第一个匹配元素外部宽度（默认包括补白和边框）。此方法对可见和隐藏元素均有效。 offset([coordinates])：获取匹配元素在当前视口的相对偏移。返回的对象包含两个整型属性：top 和 left，以像素计。方法只对可见元素有效。position()：获取匹配元素相对父元素的偏移。返回的对象包含两个整型属性：top 和 left。此方法只对可见元素有效。 jQuery 动画 show([speed, [easing], [callback]])：显示隐藏的匹配元素。hide([speed, [easing], [callback]])：隐藏显示的元素。toggle([speed, [easing], [callback]])：如果元素是可见的，切换为隐藏的，如果元素是隐藏的，切换为可见的。speed：三种预定速度的字符串（slow、normal、fast）或者动画时长的毫秒数值。easing：指定切换效果，默认是 swing，可用 linear。callback：在动画完成时执行的函数，每个元素执行一次。运动过程中：改变 width、height、margin、padding、opacity 属性值。 slideDown([speed, [easing], [callback]])：通过高度变化（向下增大）来动态的显示所有匹配的元素，显示完成后可选的触发一个回调函数。slideUp([speed, [easing], [callback]])：通过高度变化（向上减小）来动态的隐藏所有匹配的元素，隐藏完成后可选的触发一个回调函数。slideToggle([speed, [easing], [callback]])：通过高度变化来切换所有匹配元素的可见性，切换完成后可选的触发一个回调函数。speed：三种预定速度的字符串（slow、normal、fast）或者动画时长的毫秒数值。easing：指定切换效果，默认是 swing，可用 linear。callback：在动画完成时执行的函数，每个元素执行一次。运动过程中：改变 height、margin-top、margin-bottom、padding-top、padding-bottom 属性值。 fadeIn([speed, [easing], [callback]])：通过不透明度的变化来实现所有匹配元素的淡入效果，动画完成后可选的触发一个回调函数。fadeOut([speed, [easing], [callback]])：通过不透明度的变化来实现所有匹配元素的淡出效果，动画完成后可选的触发一个回调函数。fadeTo([speed, opacity, [easing], [callback]])：把所有匹配元素的不透明度以渐进方式调整到指定的不透明度，动画完成后可选的触发一个回调函数。opacity：一个 0 到 1 之间表示透明度的数字。fadeToggle([speed, [easing], [callback]])：通过不透明度的变化来开关所有匹配元素的淡入淡出效果，动画完成后可选的触发一个回调函数。speed：三种预定速度的字符串（slow、normal、fast）或者动画时长的毫秒数值。easing：指定切换效果，默认是 swing，可用 linear。callback：在动画完成时执行的函数，每个元素执行一次。注：fadeIn、fadeout、fadeToggle，运动过程中修改 opacity 属性值，最终只修改 display 属性值。而 fadeTo 只修改 opacity 属性值。 animate(params, [speed], [easing], [fn])：用于创建自定义动画的函数。params：一组包含作为动画属性和终值的样式属性和及其值的集合。speed：三种预定速度的字符串（slow、normal、fast）或者动画时长的毫秒数值。easing：指定切换效果，默认是 swing，可用 linear。fn：在动画完成时执行的函数，每个元素执行一次。 stop(clearQueue, [jumpToEnd])：停止所有在指定元素上正在运行的动画。如果 clearQueue 没有设置为 true，并且队列中有等待执行的动画，他们将马上执行。clearQueue：如果同一元素调用多个动画方法，尚未被执行的动画被放置在元素的效果队列中。这些动画不会开始，直到第一个完成。调用 stop()的时候，队列中的下一个动画开始。如果 clearQueue 参数为 true，那么在队列中的动画其余被删除并永远不会被执行。jumpToEnd：当前动画将停止，但该元素上的 CSS 属性会被立刻修改成动画的目标值。 delay(duration)：设置一个延时来推迟执行队列中之后的项目。duration：延迟时间，单位：毫秒。 本文作者：人模人样的搬砖老段本文链接：jQuery 的一些基本内容（一）如有错误，请及时评论或者知乎私信或者 B 站私信哦~","tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"}]},{"title":"基于hexo+yilia的博客主题修改和基本设置","date":"2019-11-03T12:39:21.000Z","path":"2019/11/03/基于hexo的博客主题修改和基本设置/","text":"引言 这种主题修改适用于对博客了解不深的菜鸟们(我就是其中一员)和那些不不想花费太多时间在自定义主题上的，我找了两篇教程就开始着手修改了，导致中间出现了一些问题，建议想要修改主题的多去看几篇教程，最好先了解一下中间可能会出现什么问题，做好心理准备。 选主题 这里先放一个 hexo 官网的主题库，可以选一下想要的主题，我的主题是选的以前收藏的一个博主的博客主题。https://hexo.io/themes/选好了主题，在 github 上找到相应的项目。(托管在其他平台的我不太清楚，目前只会操作托管在 github 上的主题项目) 下载主题 在你的博客文件目录下打开 git Bash，执行下列命令： 1$ git clone https:&#x2F;&#x2F;github.com&#x2F;litten&#x2F;hexo-theme-yilia.git themes&#x2F;yilia 然后打开你的博客目录，会发现 themes 文件下多出了一个 yilia 文件夹。 修改配置 打开博客文件根目录下的_config.yml 文件，进行修改。 1theme: yilia # 初始值应该是landscape 然后执行下列代码更新配置 123cd themes&#x2F;yiliagit pull 然后执行 hexo s 就可以在本地看到更新后的主题了。 完善主题配置(针对 yilia) 主要配置可以参考以下文章：github 上 yilia 主题的安装教程：https://github.com/litten/hexo-theme-yilia关于 hexo yilia 主题配置走过的坑:https://www.jianshu.com/p/f6f19b02c661Hexo4.扩展主题的个性化设置-Hexo(yilia)+GitHub Pages 搭建个人博客系列文章:https://blog.csdn.net/weixin_41287260/article/details/97693850 注： 如果有其他不懂得地方建议多参考官方教程和相关教程，多搜索，读文档，慢慢修改，先本地服务器查看一下，确认无误后再上传到 giuhub 配置好主题后就可以再执行以下命令重新部署到github上了。 123$ hexo cl$ hexo g$ hexo d 本文作者：人模人样的搬砖老段本文链接:http://dxh98.cn/%E5%9F%BA%E4%BA%8Ehexo%E7%9A%84%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E4%BF%AE%E6%94%B9%E5%92%8C%E5%9F%BA%E6%9C%AC%E8%AE%BE%E7%BD%AE/如有错误，请及时评论或者知乎私信或者 B 站私信哦~","tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"yilia","slug":"yilia","permalink":"http://yoursite.com/tags/yilia/"},{"name":"github","slug":"github","permalink":"http://yoursite.com/tags/github/"}]},{"title":"hexo+yilia搭建博客的坎坷历程","date":"2019-10-20T11:14:49.000Z","path":"2019/10/20/hexo-yilia搭建博客的坎坷历程/","text":"我为什么要搭建一篇博客？ 之前在学习的过程中，遇到过的很多问题，基本上都是通过百度解决的，然后也见了很多人搭建了自己博客，并且每个人的博客对于他们来说的作用都不一样，我决定搭建一个博客也是觉得我的学习历程可以被记录下来，就当做我在前端进阶之路上的一个日记本吧。 也有出于挑战一下的心态，我选了 hexo 加 github 搭建博客，hexo 还没接触过，但是知道这样搭建的博客还是基于 node.js 的，同时也希望在搭建的过程中学习到一些新的东西。 反正酷就完事儿了！ 1这是我的第一篇原创文章 前期准备 我的系统：windows7 64 位 编辑器：vsCode 控制台：git 安装 Node.js:https://nodejs.org/en/ 安装 Git:https://github.com/waylau/git-for-win教程可以参考廖雪峰老师的教程：https://github.com/waylau/git-for-win安装完成后，打开安装到的文件地址，打开 Git-Git Bash ,名称和邮箱是 github 上的。(我忘记登录这一步是不是在这里了，如果没有找到需要登录的地方，先不做) 安装 hexo,这一步是开始菜单里找到 Git Bash，也可以去 git 文件的根目录打开，执行下面的代码下载 hexo。$ npm install -g hexo-cli如果你成功安装了这些东西，基本的环境就已经配置好了。 注：也许在安装过程中会遇到一些问题，可以百度搜索相关安装教程，我在这个过程中也遇到了很多问题，基本都是搜索然后一个一个尝试去解决的。 配置 Github 首先需要注册登录https://github.com/拥有自己的账号密码，一定要记住自己的账号名，因为这个账号名要作为你的仓库名，也会成为你的博客域名的一部分。右上角选择新建一个仓库，也就是 Create a new repositoryhttps://github.com/newRepository name 填自己的名字yourname.github.io（yourname 要与你的注册名一致，也就是你的账号名，即为你的博客的域名） 设置 安装完成所有东西后，继续在 git 控制台里执行命令，Hexo 会 在指定的文件夹中新建所需要的文件 123$ hexo init myblog #blog是博客文件夹名可以自己指定的$ cd myblog #进入该文件夹$ npm install #补全依赖环境 执行完这些就在文件夹中生成了一个 myblog 的文件夹。然后执行下列代码： 12$ hexo generate #生成静态页$ hexo server #启动本地服务器，可以在本地服务器中查看自带的hello Word文件 重新打开 Git，或者打开 CMD 也可以，执行下列命令：（git 前面会自带$） 1ssh-keygen -t rsa -C &quot;Github的注册邮箱地址&quot; #注意这个C是大写的 然后他会让你 enter，你就看见一个提示就 enter，然后会得到一串信息，是一个文件的路径名： 1Your public key has been saved in &#x2F;c&#x2F;Users&#x2F;user&#x2F;.ssh&#x2F;id_rsa.pub. 你需要找到这个文件，打开（sublime text），复制里面的所有内容，然后打开 Sign in to Github:https://github.com/settings/sshNew SSH key ——Title：blog —— Key：输入刚才复制的—— Add SSH key 修改博客的配置文件 在 myblog 目录下，找到_config.yml 文件，用编辑器打开，修改其中的信息。这个文件是 markdown 文件，所以要严格按照 markdown 的语法，比如参数的冒号后面都是要加空格的。网站相关信息： 123456title: #这个是网站名subtitle: 副标题description: 网页描述author: #这个是你的名字language: zh-CNtimezone: Asia&#x2F;Shanghai #时区 配置部署： 1234deploy: type: git repo: https:&#x2F;&#x2F;github.com&#x2F;dxh98.github.io.get #这里的dxh98改成你自己的github名 branch: master 发表测试文章 在控制台中输入： 1$ hexo new &quot;我的测试文章&quot; 你会看到它输出了一串文件路径，就是这篇文章的路径地址，找到这个文件，用编辑器打开，修改其中的内容，同样是 markedown 语法。此处只做测试用。markedown 语法可参照：https://www.jianshu.com/p/dd75481458be 保存文章内容，然后执行以下操作： 12345678910111213141516F:\\test\\myblog #在myblog目录下执行命令语句$ hexo cleanINFO Deleted database.INFO Deleted public folder.F:\\test\\myblog$ hexo generateINFO Start processingINFO Files loaded in 1.48 s#省略INFO 29 files generated in 4.27 sF:\\test\\myblog$ hexo serverINFO Start processingINFO Hexo is running at http:&#x2F;&#x2F;localhost:4000&#x2F;. Press Ctrl+C to stop. 然后你可以打开http://localhost:4000/，发现刚刚创建的测试文章已经出现了。最后,发布到 github 上就可以了。 123456F:\\test\\myblog$ hexo deployINFO Deploying: gitINFO Clearing .deploy_git folder...INFO Copying files from public folder...#省略 其中会提示验证你是谁，你需要输入自己的 github 名和邮箱，然后会跳出 github 登录，登陆一下就好了，以后就不用了再登录了。 然后进入你的博客的网址https://dxh98.github.io/,就可以看到成功发布了文章。 以后再发布文章就可以通过已下的命令来创建文章。 1$ hexo new &quot;文章名&quot; 修改好文章后，可以先通过一下代码先在本地服务器查看： 1$ hexo s # s 即为server的简写 文章内容没有问题后，就可已通过以下代码上传到 github： 123$ hexo g # g 即为generate的简写$ hexo d # d 即为deploy的缩写 如果上传后的网站内容与预览内容不一致，可以执行以下代码： 1$ hexo cl # cl 即为clean的缩写 注：如果过程中出现了报错等问题，大部分都可以通过百度解决。 参考文章：(我就是看着这些一步一步把博客搭建起来的) 教你免费搭建个人博客，Hexo&amp;Githubhttps://zhangslob.github.io/2017/02/28/%E6%95%99%E4%BD%A0%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%8CHexo-Github/ 使用 Hexo+服务器搭建个人博客https://www.jianshu.com/p/6ae883f9291c 使用 Github 和 Hexo 快速搭建个人博客https://cloud.tencent.com/developer/article/1004760 hexo+github 搭建个人博客https://www.jianshu.com/p/6745fe11bc7f 本文作者：人模人样的搬砖老段本文链接:http://dxh98.cn/hexo-yilia%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%9D%8E%E5%9D%B7%E5%8E%86%E7%A8%8B/如有错误，请及时评论或者知乎私信或者 B 站私信哦~","tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"yilia","slug":"yilia","permalink":"http://yoursite.com/tags/yilia/"},{"name":"github","slug":"github","permalink":"http://yoursite.com/tags/github/"}]},{"title":"面向对象","date":"2019-10-05T16:03:53.000Z","path":"2019/10/06/面向对象/","text":"面向对象概念面向对象(Object Oriented,OO)是软件开发方法。面向对象的概念和应用已超越了程序设计和软件开发，扩展到如数据库系统、交互式界面、应用结构、应用平台、分布式系统、网络管理结构、CAD 技术、人工 智能等领域。面向对象是一种对现实世界理解和抽象的方法，是计算机编程技术发展到一定阶段后的产物，是一种高级的编程思想。面向对象是一种思想，很多种语言之中都有面向对象的思想，这种思想已经不同于面向过程的逻辑了。面向对象：只关注对象提供的功能， 不关注内部的细节。面向对象的特点：（封装，继承，多态） 对象的组成：方法 和 属性什么是方法和属性呢？var timer=nullDOM.timer=null 构造函数的使用 js 提供的构造函数 New Date(); 自己定义的构造函数 构造函数和对象的关系New 加构造函数创建对象 使用 Json 创建对象 1&#123; \"name\": \"wangcai\", \"age\": 2 &#125; 面相对象和面相过程的区别面向过程是一件事“该怎么做“，面向对象是一件事“该让谁来做”，然后那个“谁”就是对象，他要怎么做是他自己的事，反正最后一群对象合力能把事做好就行了。面向对象： 狗.吃(X)面向过程： 吃.(狗,X)应用：掌握面相对象编程的好处（继承 封装 多态） 类 类的概念类的概念 ： 类是具有相同属性和方法的一组对象的集合。为属于该类的所有对象提供了统一的抽象描述，其内部包括属性和方法两个主要部分 类和对象类与对象的关系就如模具和铸件的关系，类的实例化结果就是对象，而对一类对象的抽象就是类。类描述了一组有相同特性( 属性 ) 和相同行为 ( 方法 ) 的对象。 JSON 字符串和对象直接的转换 123var A = '&#123; \"a\" : 1 , \"b\" : \"hello\" &#125;';JSON.parse(A);JSON.stringify(); eval 函数eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。 123456eval(\"x=10;y=20;document.write(x*y)\");document.write(eval(\"2+2\"));var x = 10;document.write(eval(x + 17));eval(\"(\" + A + \")\"); //把字符串 转为对象 本文作者：人模人样的搬砖老段本文链接：面向对象如有错误，请及时评论或者知乎私信或者 B 站私信哦~ 最后更新于:2020/02/14","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}]},{"title":"逻辑分支","date":"2019-09-21T16:29:11.000Z","path":"2019/09/22/逻辑分支/","text":"程序的基本结构1996 年，计算机科学家 Bohm 和 Jacopini 证明了：任何简单或复杂的程序都可以由顺序结构、选择结构和循环结构这三种基本结构组合而成。三种结构都很简单，这也告诉我们任何复杂的程序，都可以由此而来。顺序结构逻辑分支结构循环结构 逻辑分支结构，选择结构也叫条件语句 if 结构（单分支）if 结构先判断一个表达式的布尔值，然后根据布尔值的真伪，执行不同的语句。所谓布尔值，指的是 JavaScript 的两个特殊值，true 表示真，false 表示伪。 if (布尔值)语句; // 或者if (布尔值) 语句; 上面是 if 结构的基本形式。需要注意的是，“布尔值”往往由一个条件表达式产生的，必须放在圆括号中，表示对表达式求值。如果表达式的求值结果为 true，就执行紧跟在后面的语句；如果结果为 false，则跳过紧跟在后面的语句。 1if (m == 3) m = m + 1; 上面代码表示，只有在 m 等于 3 时，才会将其值加上 1。这种写法要求条件表达式后面只能有一个语句。如果想执行多个语句，必须在 if 的条件判断之后，加上大括号，表示代码块（多个语句合并成一个语句）。 123if (m == 3) &#123; m += 1;&#125; 建议总是在 if 语句中使用大括号，因为这样方便插入语句。 注意，if 后面的表达式之中，不要混淆赋值表达式（=）和相等运算符（==）。尤其是赋值表达式不具有比较作用。 123456var x = 1;var y = 2;if ((x = y)) &#123; //错误示例 console.log(x);&#125; 上面代码的原意是，当 x 等于 y 的时候，才执行相关语句。但是，不小心将严格相等运算符写成赋值表达式，结果变成了将 y 赋值给变量 x，再判断变量 x 的值（等于 2）的布尔值（结果为 true）。 if…else 结构if 代码块后面，还可以跟一个 else 代码块，表示不满足条件时，所要执行的代码。 12345if (m == 3) &#123; // 满足条件时，执行的语句&#125; else &#123; // 不满足条件时，执行的语句&#125; 上面代码判断变量 m 是否等于 3，如果等于就执行 if 代码块，否则执行 else 代码块。 对同一个变量进行多次判断时，多个 if…else 语句可以连写在一起 123456789101112131415161718if (m == 0) &#123; // ...&#125; else if (m == 1) &#123; // ...&#125; else if (m == 2) &#123; // ...&#125; else &#123; // ...&#125;if (m &gt; 90) &#123; // ...A&#125; else if (m &lt; 80 &amp;&amp; m &gt; 70) &#123; // ...B&#125; else if (m &lt; 70 &amp;&amp; m &gt; 60) &#123; // ...C&#125; else &#123; // ...D&#125; switch 结构12345678910switch (fruit) &#123; case \"banana\": // ... break; case \"apple\": // ... break; default: // ...&#125; 上面代码根据变量 fruit 的值，选择执行相应的 case。如果所有 case 都不符合，则执行最后的 default 部分。需要注意的是，每个 case 代码块内部的 break 语句不能少，否则会接下去执行下一个 case 代码块，而不是跳出 switch 结构。 123456789var x = 1;switch (x) &#123; case 1: console.log(\"x 等于1\"); case 2: console.log(\"x 等于2\"); default: console.log(\"x 等于其他值\");&#125; 上面代码中，case 代码块之中没有 break 语句，导致不会跳出 switch 结构，而会一直执行下去。这种效果叫穿透。正确的写法是像下面这样。 12345678910switch (x) &#123; case 1: console.log(\"x 等于1\"); break; case 2: console.log(\"x 等于2\"); break; default: console.log(\"x 等于其他值\");&#125; 有些时候我们可以利用穿透效果简单代码 123456789101112switch (month) &#123; case 2: console.log('28或者29天') ； break; case 1: case 3: case 5: console.log('31天'); break; default: console.log('30天');&#125; 本文作者：人模人样的搬砖老段本文链接：逻辑分支如有错误，请及时评论或者知乎私信或者 B 站私信哦~ 最后更新于:2020/02/14","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"逻辑分支","slug":"逻辑分支","permalink":"http://yoursite.com/tags/%E9%80%BB%E8%BE%91%E5%88%86%E6%94%AF/"}]},{"title":"JS基本语法","date":"2019-09-08T14:45:06.000Z","path":"2019/09/08/JS基本语法/","text":"JavaScript 基本介绍及发展趋势ECMAScript通过 ECMA-262 标准化的脚本程序语言，JavaScript 是其实现和扩展。1999 年 ES3 发布，成为 JavaScript 的通行标准。2009 年 ES5 发布，在所有现代浏览器中得到了相当完全的实现2015 年 ES6 发布，被部分实现于大部分现代浏览器 原生应用 web 应用 （跨平台） appJavaScript 概念JavaScript 是基于对象和事件驱动，并具有安全性能的客户端脚本语言，弱类型的语言。解释执行 （编译-》代码转为 0 和 1）由三部分组成：ECMAScript（核心）DOM（文档对象模型）document object modelBOM（浏览器对象模型）browser object model高级编程， 面向对象编程 JavaScript 和 HTML5 的关系HTML5 的新特性新的内容元素新的表单控件媒介元素绘画本地存储 广义的 HTML5 是包括 HTML、CSS、JavaScript 在内的一套技术组合狭义的 HTML5 更多的是指 JavaScript. 编写 JS 及如何运行 JS 在 HTML 标签中直接写入 JS 代码（用的少） &lt;div id=&#39;div1&#39; onclick=&#39;alert(“你好”)&#39;&gt;点击&lt;/div&gt; 在 HTML 文档中写入代码&lt;script&gt;&lt;/script&gt; 在*.js 文件中写入 JS 代码(工作中常用)&lt;script src=”a.js”&gt;&lt;/script&gt; 注释///**/ 变量及命名规则 变量的声明和定义var a = 10;var 是关键字， a 是变量名， =是赋值符号 10 是值 变量的命名规则变量是由数字、字母、下划线（_）和美元符号（$）的一种或者几种组成，且不能以数字开头,严格区分大小写。（驼峰法则，见名知义） 关键字ECMAScript 描述了一组特定用途的关键字，不能用作变量名，例如：If else do while for in 等。 算术、赋值、关系运算符算术运算符 1+ - * / % 赋值运算符 1= += -= *= /= %= 关系运算符 1&gt; &lt; &gt;= &lt;= == != === !== var num = 3.11111num.toFixed(3)// toFixed(n) 保留 n 位小数 数据类型及类型转换JavaScript 数据类型数值、字符串、布尔、undefined、null、对象 JavaScript 类型转换隐式转换显式转换 逻辑运算符逻辑与 &amp;&amp; and 逻辑或 || or 逻辑非 ！ not 自增自减运算自增++自减– 八进制和十六进制八进制 071十六进制 0x12 Number 方法的应用，NaNNaN(not a number):不是一个数字Number()：将值转化为数字 本文作者：人模人样的搬砖老段本文链接：JS 基本语法如有错误，请及时评论或者知乎私信或者 B 站私信哦~ 最后更新于:2020/02/14","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"循环语句","date":"2019-08-25T04:40:08.000Z","path":"2019/08/25/循环语句/","text":"循环语句循环的概念和意义循环结构是指在程序中需要反复执行某个功能而设置的一种程序结构。它由循环体中的条件，判断继续执行某个功能还是退出循环 循环结构可以减少源程序重复书写的工作量，这是程序设计中最能发挥计算机特长的程序结构 。 简单的理解循环语句用于重复执行某个操作，它有多种形式。 while 循环While 语句包括一个循环条件和一段代码块，只要条件为真，就不断循环执行代码块。while (条件) {语句;}while 语句的循环条件是一个表达式，必须放在圆括号中。代码块部分，如果只有一条语句，可以省略大括号， 否则就必须加上大括号。下面的例子是一个无限循环，因为循环条件总是为真。注：写程序的时候尽量不要出现死循环 123while (true) &#123; console.log(\"Hello, world\");&#125; 下面是 while 语句的一个例子。 12345var i = 0;while (i &lt; 100) &#123; console.log(\"i 当前为：\" + i); i = i + 1;&#125; 上面的代码将循环 100 次，直到 i 等于 100 为止。 do…while 循环do…while 循环与 while 循环类似，唯一的区别就是先运行一次循环体，然后判断循环条件。do {语句} while (条件); 不管条件是否为真，do…while 循环至少运行一次，这是这种结构最大的特点。另外，while 语句后面的分号注意不要省略。 123456var x = 3;var i = 0;do &#123; console.log(i); i++;&#125; while (i &lt; x); for 循环的使用for 语句是循环命令的另一种形式，可以指定循环的起点、终点和终止条件。它的格式如下。for (初始化表达式; 条件; 递增表达式) {语句}for 语句后面的括号里面，有三个表达式。 初始化表达式（initialize）：确定循环变量的初始值，只在循环开始时执行一次。条件表达式（test）：每轮循环开始时，都要执行这个条件表达式，只有值为真，才继续进行循环。递增表达式（increment）：每轮循环的最后一个操作，通常用来递增循环变量。 1234var x = 3;for (var i = 0; i &lt; x; i++) &#123; console.log(i);&#125; 上面代码中，初始化表达式是 var i = 0，即初始化一个变量 i；测试表达式是 i &lt; x，即只要 i 小于 x，就会执行循环；递增表达式是 i++，即每次循环结束后，i 增大 1。 break 语句break 语句用于跳出代码块或循环。 123456var i = 0;while (i &lt; 100) &#123; console.log(\"i 当前为：\" + i); i++; if (i === 10) break;&#125; 上面代码只会执行 10 次循环，一旦 i 等于 10，就会跳出循环。 for 循环也可以使用 break 语句跳出循环。 1234for (var i = 0; i &lt; 5; i++) &#123; console.log(i); if (i === 3) break;&#125; 上面代码执行到 i 等于 3，就会跳出循环 continue 语句continue 语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环。 123456var i = 0;while (i &lt; 100) &#123; i++; if (i % 2 === 0) continue; console.log(\"i 当前为：\" + i);&#125; 上面代码只有在 i 为奇数时，才会输出 i 的值。如果 i 为偶数，则直接进入下一轮循环。 for 循环的嵌套，也称多层循环 1234567891011for (var i = 0; i &lt; 10; i++) &#123; //外层循环 //外层循环执行一次，内层循环执行十次 for (var j = 0; j &lt; 10; j++) &#123; //内层循环 document.write(\"*\"); &#125; document.write(\"&lt;br/&gt;\");&#125; break 语句和 continue 语句都具有跳转作用，可以让代码不按既有的顺序执行。 死循环 （不知道循环次数的时候用死循环，在适当的时候结束循环） 本文作者：人模人样的搬砖老段本文链接：循环语句如有错误，请及时评论或者知乎私信或者 B 站私信哦~ 最后更新于:2020/01/10","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"循环语句","slug":"循环语句","permalink":"http://yoursite.com/tags/%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/"}]},{"title":"函数","date":"2019-08-10T16:52:49.000Z","path":"2019/08/11/函数/","text":"函数的概念函数是一段可以反复调用的代码块。 作用在程序设计中，常将一些常用的功能模块编写成函数，以减少重复编写程序段的工作量。提高代码的复用性、可读性等 函数的创建方式（函数的声明） function 命令function 命令声明的代码区块，就是一个函数。function 命令后面是函数名，函数名后面是一对圆括号。函数体放在大括号里面。function 函数名称() {函数中要执行的代码;} 123function print() &#123; console.log(1);&#125; 上面的代码命名了一个 print 函数，以后使用 print()这种形式，就可以调用相应的代码。这叫做函数的声明 函数表达式除了用 function 命令声明函数，还可以采用变量赋值的写法。 123var print = function () &#123; console.log(1);&#125;; 这种写法将一个匿名函数（没有名字的函数）赋值给变量。这时，这个匿名函数又称函数表达式 函数的执行(调用)函数定义好之后，函数中的代码在程序运行过程中不会执行； 123function print() &#123; console.log(1);&#125; 通过函数名称调用函数，调用时执行函数中的代码；调用函数时，要使用圆括号运算符print(); 事件的概念种类事件：就是发生的事情事件驱动：就是发生了某件事情之后要处理的手段和过程 鼠标事件onclick 鼠标单击ondbclick 鼠标双击onmousedown 鼠标按键按下onmouseup 鼠标按键抬起onmousemove 鼠标在元素上移动onmouseout 鼠标移出onmouseenter 鼠标移入 键盘事件onkeydown 键盘按键按下onkeyup 键盘按键抬起onkeypress 键盘按键按住 表单事件onblur 失去焦点onfocus 获取焦点onchange 内容修改 参数的声明函数名后面是一对圆括号，里面是传入函数的参数function 函数名称(参数列表){函数体中的代码;}函数定义的时候的参数，称为形参 123456function print(s) &#123; console.log(s);&#125;function add(a, b) &#123; console.log(a + b);&#125; 参数的传递print（1）； 调用函数的时候，传入了 参数 1，1 的值给了形参 s。函数调用时候传入的参数叫做实参 函数的返回值JavaScript 引擎遇到 return 语句，就直接返回 return 后面的那个表达式的值,后面即使还有语句，也不会得到执行。也就是说，return 语句所带的那个表达式，就是函数的返回值。 注、return 语句不是必需的，如果没有的话，该函数就不返回任何值，或者说返回 undefined。 12345function add(x, y) &#123; return x + y; //返回x+y的和&#125;var res = add(1, 1); //把函数的返回值 赋值给 变量resconsole.log(res); //2 变量的声明提升函数内部会产生“变量提升”现象。在函数内部使用 var 命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部。 123456789101112function foo(x) &#123; if (x &gt; 100) &#123; var tmp = x - 100; &#125;&#125;// 等同于function foo(x) &#123; var tmp; if (x &gt; 100) &#123; tmp = x - 100; &#125;&#125; arguments由于 JavaScript 允许函数有不定数目的参数，所以需要一种机制，可以在函数体内部读取所有参数。这就是 arguments 对象的由来。arguments 对象包含了函数运行时的所有参数，arguments[0]就是第一个参数，arguments[1]就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。 123456var f = function (one) &#123; console.log(arguments[0]); console.log(arguments[1]); console.log(arguments[2]);&#125;;f(1, 2, 3); 通过 arguments 对象的 length 属性，可以判断函数调用时到底带几个参数 作用域作用域（scope）指的是变量存在的范围。局部作用域和全局作用域在 ES5 的规范中，Javascript 只有两种作用域：一种是全局作用域，变量在整个程序中一直存在，所有地方都可以读取；另一种是函数作用域，变量只在函数内部存在。 函数外部声明的变量就是全局变量（global variable）在函数内部定义的(使用 var)变量，外部无法读取，顾称为“局部变量”（local variable） 1234567var v = 1; //全局变量function f() &#123; var b = 2; //局部变量 console.log(b); console.log(v); //它在函数内部可以读取全局变量，但是局部变量的不能再函数外部访问&#125;f(); 上面的代码表明，函数 f 内部可以读取全局变量 v。 函数内部定义的变量，会在该作用域内覆盖同名全局变量。（山高皇帝远，县官不如现管） 1234567var v = 1;function f() &#123; var v = 2; console.log(v);&#125;f(); // 2v; // 1 上面代码中，变量 v 同时在函数的外部和内部有定义。结果，在函数内部定义，局部变量 v 覆盖了全局变量 v。 注意，对于 var 命令来说，局部变量只能在函数内部声明，在其他区块中声明，一律都是全局变量。 1234if (true) &#123; var x = 5;&#125;console.log(x); // 5 上面代码中，变量 x 在条件判断区块之中声明，结果就是一个全局变量，可以在区块之外读取。 递归函数函数可以调用自身，这就是递归。 简单来说，就是函数自己执行过程中，调用自己本身。 f（n）求前 n 项和 123F(n)=F(n-1)+n = F(n-2)+n-1 +n= F(n-3)+n-2 + n-1 + n...... F(1)+2+3+4.... n-1 + n// F(100)= F(99)+100= F(98)+99+100 = F(1)+2+3+4.....+99+100 递归的步骤： 先找临界值，即无需计算 就能获取的值 找本次 和上一次的关系 f（n） = f(n-1)+n (数学归纳) 假设 当前函数已经可以使用了，调用自身计算上一次的运行结果，再写出本次运行结果 即可 123456789101112//求1-n之间的和//1 ........ 100// 1- 1000//1. 临界值1//2. sum(n-1)+n = sum(n)function sum1(n) &#123; //临界值 if (n == 1) &#123; return 1; &#125; return sum1(n - 1) + n;&#125; 构造函数及对象类型面向对象编程（Object Oriented Programming，缩写为 OOP）是目前主流的编程范式。它将真实世界各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。 面向对象编程的第一步，就是要生成对象。对象是单个实物的抽象。通常需要一个模板，表示某一类实物的共同特征，然后对象根据这个模板生成 JavaScript 语言使用构造函数（constructor）作为对象的模板。所谓”构造函数”，就是专门用来生成实例对象的函数。它就是对象的模板，描述实例对象的基本结构。一个构造函数，可以生成多个实例对象，这些实例对象都有相同的结构。 构造函数就是一个普通的函数，但是有自己的特征和用法。 123function Vehicle() &#123; this.price = 1000;&#125; 上面代码中，Vehicle 就是构造函数。为了与普通函数区别，构造函数名字的第一个字母通常大写。构造函数的特点有两个。函数体内部使用了 this 关键字，代表了所要生成的对象实例。生成对象的时候，必须使用 new 命令 new 命令的作用，就是执行构造函数，返回一个实例对象。 12345function Vehicle() &#123; this.price = 1000;&#125;var v = new Vehicle();v.price; // 1000 上面代码通过 new 命令，让构造函数 Vehicle 生成一个实例对象，保存在变量 v 中。这个新生成的实例对象，从构造函数 Vehicle 得到了 price 属性。new 命令执行时，构造函数内部的 this，就代表了新生成的实例对象，this.price 表示实例对象有一个 price 属性，值是 1000。 本文作者：人模人样的搬砖老段本文链接：函数如有错误，请及时评论或者知乎私信或者 B 站私信哦~ 最后更新于:2020/02/10","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"函数","slug":"函数","permalink":"http://yoursite.com/tags/%E5%87%BD%E6%95%B0/"}]},{"title":"数组","date":"2019-07-28T06:53:47.000Z","path":"2019/07/28/数组/","text":"数组的概念所谓数组，是有序的元素序列。（一组有序 数据）JavaScript 的 Array 可以包含任意数据类型。注：一般来说数组中元素的类型相同 数组的创建方式 字面量 12345var arr = [1, 2]; //数组中有两个元素arr.length; //获取数组的长度arr[i]; //获取数组中的第i个元素，i称为数组的下标或者索引，下标从0开始arr[0]; //获取数组中的第一个元素arr[0] = 100; //修改数组中第一个元素的值为100 构造函数方式创建数组Array 是一个构造函数，可以用它生成新的数组 123var arr = new Array(2);arr.length; // 2arr[0]; //undefined 上面代码中，Array 构造函数的参数 2，表示生成一个两个成员的数组。 Array 构造函数有一个很大的缺陷，就是不同的参数，会导致它的行为不一致。 123456// 单个非数值（比如字符串、布尔值、对象等）作为参数，// 则该参数是返回的新数组的成员new Array(\"abc\"); // ['abc']// 多参数时，所有参数都是返回的新数组的成员new Array(1, 2); // [1, 2]new Array(\"a\", \"b\", \"c\"); // ['a', 'b', 'c'] 可以看到，Array 作为构造函数，行为很不一致。因此，不建议使用它生成新数组，直接使用数组字面量是更好的做法。 数组的操作push/pop/unshift/shift push方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组 12345var arr = [];arr.push(1); // 1arr.push(\"a\"); // 2arr.push(true, &#123;&#125;); // 4arr; // [1, 'a', true, &#123;&#125;] pop方法用于删除数组的最后一个元素，并返回该元素。注意，该方法会改变原数组。 123var arr = [\"a\", \"b\", \"c\"];arr.pop(); // 'c'arr; // ['a', 'b'] 对空数组使用 pop 方法，不会报错，而是返回 undefined。 push 和 pop 结合使用，就构成了“后进先出”的栈结构（stack）。 12345var arr = [];arr.push(1, 2);arr.push(3); //1,2,3arr.pop();arr; // [1, 2] 上面代码中，3 是最后进入数组的，但是最早离开数组。concat 合并数组 shift方法用于删除数组的第一个元素，并返回该元素。注意，该方法会改变原数组。 123var a = [\"a\", \"b\", \"c\"];a.shift(); // 'a'a; // ['b', 'c'] push 和 shift 结合使用，就构成了“先进先出”的队列结构（queue）。 unshift方法用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。 123var a = [\"a\", \"b\", \"c\"];a.unshift(\"x\"); // 4a; // ['x', 'a', 'b', 'c'] slice/splice slice方法用于复制目标数组的一部分，返回一个新数组，原数组不变。arr.slice(start, end);它的第一个参数为起始位置（从 0 开始），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。 123456var a = [\"a\", \"b\", \"c\"];a.slice(0); // [\"a\", \"b\", \"c\"]a.slice(1); // [\"b\", \"c\"]a.slice(1, 2); // [\"b\"]a.slice(2, 6); // [\"c\"]a.slice(); // [\"a\", \"b\", \"c\"] 上面代码中，最后一个例子 slice 没有参数，实际上等于返回一个原数组的拷贝。 如果 slice 方法的参数是负数，则表示倒数计算的位置。 123var a = [\"a\", \"b\", \"c\"];a.slice(-2); // [\"b\", \"c\"]a.slice(-2, -1); // [\"b\"] 上面代码中，-2 表示倒数计算的第二个位置，-1 表示倒数计算的第一个位置。 如果第一个参数大于等于数组长度，或者第二个参数小于第一个参数，则返回空数组。 123var a = [\"a\", \"b\", \"c\"];a.slice(4); // []a.slice(2, 1); // [] splice方法用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组。arr.splice(start, count, addElement1, addElement2, ...);splice 的第一个参数是删除的起始位置（从 0 开始），第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。 123var a = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"];a.splice(4, 2); // [\"e\", \"f\"]a; // [\"a\", \"b\", \"c\", \"d\"] 上面代码从原数组 4 号位置，删除了两个数组成员。 123var a = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"];a.splice(4, 2, 1, 2); // [\"e\", \"f\"]a; // [\"a\", \"b\", \"c\", \"d\", 1, 2] 上面代码除了删除成员，还插入了两个新成员。起始位置如果是负数，就表示从倒数位置开始删除。 12var a = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"];a.splice(-4, 2); // [\"c\", \"d\"] 上面代码表示，从倒数第四个位置 c 开始删除两个成员。 如果只是单纯地插入元素，splice 方法的第二个参数可以设为 0。 123var a = [1, 1, 1];a.splice(1, 0, 2); // [] 在 删除位置的前面添加了a; // [1, 2, 1, 1] 如果只提供第一个参数，等同于将原数组在指定位置拆分成两个数组。 123var a = [1, 2, 3, 4];a.splice(2); // [3, 4]a; // [1, 2] reverse/sort reverse方法用于颠倒排列数组元素，返回改变后的数组(还是原数组)。注意，该方法将改变原数组。 123var a = [\"a\", \"b\", \"c\"];a.reverse(); // [\"c\", \"b\", \"a\"]a; // [\"c\", \"b\", \"a\"] sort方法对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。 123456789101112131415[\"d\", \"c\", \"b\", \"a\"] .sort() [ // ['a', 'b', 'c', 'd'] (4, 3, 2, 1) ].sort() [ // [1, 2, 3, 4] (11, 101) ].sort() [ // [101, 11] (10111, 1101, 111) ].sort();// [10111, 1101, 111] 上面代码的最后两个例子，需要特殊注意。sort 方法不是按照大小排序，而是按照字典顺序。也就是说，数值会被先转成字符串，再按照字典顺序进行比较，所以 101 排在 11 的前面。 如果想让 sort 方法按照自定义方式排序，可以传入一个函数作为参数。 1234[10111, 1101, 111].sort(function (a, b) &#123; return a - b; //升序&#125;);// [111, 1101, 10111] 上面代码中，sort 的参数函数本身接受两个参数，表示进行比较的两个数组成员。如果该函数的返回值大于 0，表示第一个成员排在第二个成员后面；其他情况下，都是第一个元素排在第二个元素前面 joinjoin 方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔。 123456789var a = [1, 2, 3, 4];a.join(' ') // '1 2 3 4'a.join(' | ') // \"1 | 2 | 3 | 4\"a.join() // \"1,2,3,4\"//如果数组成员是undefined或null或空位，会被转成空字符串。[undefined, null].join('#')// '#'['a',, 'b'].join('-')// 'a--b' 数组的遍历（for）整数数组/字符串数组/对象数组/二维数组for-in循环 for(var i in arr)i 是下标for(var i in obj) i 是属性名函数的值传递和引用传递堆和栈及索引思维JSON 表示对象的方法随机点名程序数组的排序（冒泡，选择） 数组的冒泡排序冒泡排序的视频 思路分析：在要排序的一组数中，对当前还未排好的序列，从前往后对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。 即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。 1234567891011121314151617var arr = [5, 1, 3, 2, 4];//1,5,3,2,4//1 , 3,5,2,4//1,3 2,5,4//1,3,2 4, 5//外层循环 执行4 次，每次找到一个最大的数字放在 尾部for (var i = 0; i &lt; 5 - 1; i++) &#123; console.log(i); for (var j = 0; j &lt; 5 - i - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; //交换数组两个元素的值 var t = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = t; &#125; &#125;&#125; 选择排序思路分析：选择排序和冒泡排序类似，跟冒泡不同之处在于，它不是每比较一次就调换位置，而是一轮比较完毕，找到最大值(或者最小值)之后，将其放在正确的位置，其他数的位置不变。 12345678910111213141516171819//选择排序 ，每次选择一个最小值 ，放特定位置上//外层控制比较轮数，每轮找到最小值 跟i位置上的元素进行交换for (var i = 0; i &lt; array.length - 1; i++) &#123; var minIndex = i; var min = array[i]; for (var j = i + 1; j &lt; array.length; j++) &#123; //当循环出来的元素 比最小值 小的时候，最小值发生变化，最小值索引也变化 if (min &gt; array[j]) &#123; min = array[j]; minIndex = j; &#125; &#125; //确定了最小值以后需要给 i位置上的元素进行交换 if (minIndex != i) &#123; var tmp = array[i]; array[i] = array[minIndex]; array[minIndex] = tmp; &#125;&#125; 本文作者：人模人样的搬砖老段本文链接：数组如有错误，请及时评论或者知乎私信或者 B 站私信哦~ 最后更新于:2020/04/20","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"关于ES5和字符串string","date":"2019-07-14T13:22:09.000Z","path":"2019/07/14/关于ES5和字符串string/","text":"ECMAScript 发展史ECMAScript 是一种由 ECMA 国际（前身为欧洲计算机制造商协会,英文名称是 European Computer Manufacturers Association）通过 ECMA-262 标准化的脚本程序设计语言。这种语言在万维网上应用广泛，它往往被称为 JavaScript 或 JScript，所以它可以理解为是 javascript 的一个标准,但实际上后两者是 ECMA-262 标准的实现和扩展。 1998 年 6 月，ECMAScript 2.0 版发布。1999 年 12 月，ECMAScript 3.0 版发布，成为 JavaScript 的通行标准，得到了广泛支持。2007 年 10 月，ECMAScript 4.0 版草案发布，对 3.0 版做了大幅升级，预计次年 8 月发布正式版本。草案发布后，由于 4.0 版的目标过于激进，各方对于是否通过这个标准，发生了严重分歧。以 Yahoo、Microsoft、Google 为首的大公司，反对 JavaScript 的大幅升级，主张小幅改动；以 JavaScript 创造者 Brendan Eich 为首的 Mozilla 公司，则坚持当前的草案。2008 年 7 月，由于对于下一个版本应该包括哪些功能，各方分歧太大，争论过于激进，ECMA 开会决定，中止 ECMAScript 4.0 的开发，将其中涉及现有功能改善的一小部分，发布为 ECMAScript 3.1，而将其他激进的设想扩大范围，放入以后的版本，由于会议的气氛，该版本的项目代号起名为 Harmony（和谐）。会后不久，ECMAScript 3.1 就改名为 ECMAScript 5。2009 年 12 月，ECMAScript 5.0 版正式发布。Harmony 项目则一分为二，一些较为可行的设想定名为 JavaScript.next 继续开发，后来演变成 ECMAScript 6；一些不是很成熟的设想，则被视为 JavaScript.next.next，在更远的将来再考虑推出。2011 年 6 月，ECMAscript 5.1 版发布，并且成为 ISO 国际标准（ISO/IEC 16262:2011）。2013 年 3 月，ECMAScript 6 草案冻结，不再添加新功能。新的功能设想将被放到 ECMAScript 7。2013 年 12 月，ECMAScript 6 草案发布。然后是 12 个月的讨论期，听取各方反馈。2015 年 6 月 17 日，ECMAScript 6 发布正式版本，即 ECMAScript 2015。 ES5 严格模式严格模式除了正常的运行模式，JavaScript 还有第二种运行模式：严格模式（strict mode）。顾名思义，这种模式采用更加严格的 JavaScript 语法。同样的代码，在正常模式和严格模式中，可能会有不一样的运行结果。一些在正常模式下可以运行的语句，在严格模式下将不能运行。 设计目的早期的 JavaScript 语言有很多设计不合理的地方，但是为了兼容以前的代码，又不能改变老的语法，只能不断添加新的语法，引导程序员使用新语法。严格模式是从 ES5 进入标准的，主要目的有以下几个。 明确禁止一些不合理、不严谨的语法，减少 JavaScript 语言的一些怪异行为。 增加更多报错的场合，消除代码运行的一些不安全之处，保证代码运行的安全。 提高编译器效率，增加运行速度。 为未来新版本的 JavaScript 语法做好铺垫。总之，严格模式体现了 JavaScript 更合理、更安全、更严谨的发展方向 启用方法进入严格模式的标志，是一行字符串 use strict。‘use strict’;老版本的引擎会把它当作一行普通字符串，加以忽略。新版本的引擎就会进入严格模式。严格模式可以用于整个脚本，也可以只用于单个函数 整个脚本文件use strict 放在脚本文件的第一行，整个脚本都将以严格模式运行。如果这行语句不在第一行就无效，整个脚本会以正常模式运行。(严格地说，只要前面不是产生实际运行结果的语句，use strict 可以不在第一行，比如直接跟在一个空的分号后面，或者跟在注释后面。) 1&lt;script&gt;'use strict'; console.log('这是严格模式');&lt;/script&gt; 1&lt;script&gt;console.log('这是正常模式');&lt;/script&gt; 上面代码中，一个网页文件依次有两段 JavaScript 代码。前一个&lt;script&gt;标签是严格模式，后一个不是。如果 use strict 写成下面这样，则不起作用，严格模式必须从代码一开始就生效。 1&lt;script&gt;console.log('这是正常模式'); 'use strict';&lt;/script&gt; 单个函数use strict 放在函数体的第一行，则整个函数以严格模式运行。 1234567function strict() &#123; \"use strict\"; return \"这是严格模式\";&#125;function notStrict() &#123; return \"这是正常模式\";&#125; 严格模式下的要求变量声明（必须要使用 var）函数不能有重名的参数正常模式下，如果函数有多个重名的参数，可以用 arguments[i]读取。严格模式下，这属于语法错误。 1234function f(a, a, b) &#123; \"use strict\"; return a + b;&#125; 禁止八进制的前缀 0 表示法正常模式下，整数的第一位如果是 0，表示这是八进制数，比如 0100 等于十进制的 64。严格模式禁止这种表示法，整数第一位为 0，将报错。 12\"use strict\";var n = 0100; 禁止 this 关键字指向全局对象正常模式下，函数内部的 this 可能会指向全局对象（window），严格模式禁止这种用法，避免无意间创造全局变量。 1234567891011function f() &#123; // 正常模式 console.log(this === window);&#125;f(); // truefunction f() &#123; // 严格模式 \"use strict\"; console.log(this === undefined);&#125;f(); // true 上面代码中，严格模式的函数体内部 this 是 undefined。这种限制对于构造函数尤其有用。使用构造函数时，有时忘了加 new，这时 this 不再指向全局对象，而是报错。 12345function f() &#123; \"use strict\"; this.a = 1;&#125;f(); // 报错，this 未定义 严格模式下，使用 with 语句将报错。 12345\"use strict\";var obj = &#123; v: 1 &#125;;with (obj) &#123; v = 2; //obj.v = 2;&#125; 创设 eval 作用域正常模式下，JavaScript 语言有两种变量作用域（scope）：全局作用域和函数作用域。严格模式创设了第三种作用域：eval 作用域。 正常模式下，eval 语句的作用域，取决于它处于全局作用域，还是函数作用域。严格模式下，eval 语句本身就是一个作用域，不再能够在其所运行的作用域创设新的变量了，也就是说，eval 所生成的变量只能用于 eval 内部。 123456(function () &#123; \"use strict\"; var x = 2; console.log(eval(\"var x = 5; x\")); // 5 console.log(x); // 2&#125;)(); 上面代码中，由于 eval 语句内部是一个独立作用域，所以内部的变量 x 不会泄露到外部 ES5 新增的数组方法静态方法Array.isArray()Array.isArray 方法返回一个布尔值，表示参数是否为数组。它可以弥补 typeof 运算符的不足。 123var arr = [1, 2, 3];typeof arr; // \"object\"Array.isArray(arr); // true 上面代码中，typeof 运算符只能显示数组的类型是 Object，而 Array.isArray 方法可以识别数组。 实例（对象）方法 map方法将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回。 1234567var numbers = [1, 2, 3];var res = numbers.map(function (n) &#123; return n + 1;&#125;);res; // [2, 3, 4]numbers;// [1, 2, 3] 上面代码中，numbers 数组的所有成员依次执行参数函数，运行结果组成一个新数组返回，原数组没有变化。map 方法接受一个函数作为参数。该函数调用时，map 方法向它传入三个参数：当前成员、当前位置和数组本身。 1234[1, 2, 3].map(function (elem, index, arr) &#123; return elem * index;&#125;);// [0, 2, 6] 上面代码中，map 方法的回调函数有三个参数，elem 为当前成员的值，index 为当前成员的位置，arr 为原数组（[1, 2, 3]） forEach方法与 map 方法很相似，也是对数组的所有成员依次执行参数函数。但是，forEach 方法不返回值，只用来操作数据。这就是说，如果数组遍历的目的是为了得到返回值，那么使用 map 方法，否则使用 forEach 方法。forEach 的用法与 map 方法一致，参数是一个函数，该函数同样接受三个参数：当前值、当前位置、整个数组。 1234567function log(element, index, array) &#123; console.log(\"[\" + index + \"] = \" + element);&#125;[2, 5, 9].forEach(log);// [0] = 2// [1] = 5// [2] = 9 注意，forEach 方法无法中断执行，总是会将所有成员遍历完。如果希望符合某种条件时，就中断遍历，要使用 for 循环。 12345var arr = [1, 2, 3];for (var i = 0; i &lt; arr.length; i++) &#123; if (arr[i] === 2) break; console.log(arr[i]);&#125; filter方法用于过滤数组成员，满足条件的成员组成一个新数组返回。它的参数是一个函数，所有数组成员依次执行该函数，返回结果为 true 的成员组成一个新数组返回。该方法不会改变原数组。filter 方法的参数函数可以接受三个参数：当前成员，当前位置和整个数组。 1234var res = [1, 2, 3, 4, 5].filter(function (elem, index, arr) &#123; return index % 2 === 0;&#125;);res; // [1, 3, 5] 上面代码返回偶数位置的成员组成的新数组。 reduce方法依次处理数组的每个成员，最终累计为一个值。reduce 是从左到右处理（从第一个成员到最后一个成员）reduce 方法参数是一个函数,该函数接受以下两个参数。1 累积变量，默认为数组的第一个成员2 当前变量，默认为数组的第二个成员 123456789var res = [1, 2, 3, 4, 5].reduce(function (a, b) &#123; console.log(a, b); return a + b;&#125;);// 1 2// 3 3// 6 4// 10 5res; //最后结果：15 上面代码中，reduce 方法求出数组所有成员的和。第一次执行，a 是数组的第一个成员 1，b 是数组的第二个成员 2。第二次执行，a 为上一轮的返回值 3，b 为第三个成员 3。第三次执行，a 为上一轮的返回值 6，b 为第四个成员 4。第四次执行，a 为上一轮返回值 10，b 为第五个成员 5。至此所有成员遍历完成，整个方法的返回值就是最后一轮的返回值 15。 indexOf(),lastIndexOf()indexOf 方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。 12345678var a = [\"a\", \"b\", \"c\"];a.indexOf(\"b\"); // 1a.indexOf(\"y\") // -1 [ //indexOf方法还可以接受第二个参数，表示搜索的开始位置。 (\"a\", \"b\", \"c\") ].indexOf(\"a\", 1); // -1//上面代码从1号位置开始搜索字符a，结果为-1，表示没有搜索到。 lastIndexOf 方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。 123var a = [2, 5, 9, 2];a.lastIndexOf(2); // 3a.lastIndexOf(7); // -1 注意，这两个方法不能用来搜索 NaN 的位置，即它们无法确定数组成员是否包含 NaN。 123[NaN] .indexOf(NaN) // -1 [NaN].lastIndexOf(NaN); // -1 这是因为这两个方法内部，使用严格相等运算符（===）进行比较，而 NaN 是唯一一个不等于自身的值 字符串 string字符串的创建方式1234var s1 = \"abc\";var s2 = new String(\"abc\");typeof s1; // \"string\"typeof s2; // \"object\" 上面代码中，变量 s1 是字符串，s2 是对象。所以,String 对象也叫包装对象除了用作构造函数，String 对象还可以当作工具方法使用，将任意类型的值转为字符串。 12String(true); // \"true\"String(5); // \"5\" 上面代码将布尔值 ture 和数值 5，分别转换为字符串 字符串实例的 length 属性返回字符串的长度。 1\"abc\".length; // 3 字符串对象是一个类似数组的对象（很像数组，但不是数组）。 1234new String(\"abc\")( // String &#123;0: \"a\", 1: \"b\", 2: \"c\", length: 3&#125; new String(\"abc\"))[1]; // \"b\" 上面代码中，字符串 abc 对应的字符串对象，有数值键（0、1、2）和 length 属性，所以可以像数组那样取值。 charAt 方法charAt 方法返回指定位置的字符，参数是从 0 开始编号的位置。 123456var s = new String(\"abc\");s.charAt(1); // \"b\"s.charAt(s.length - 1); // \"c\"//这个方法完全可以用数组下标替代。\"abc\".charAt(1); // \"b\"\"abc\"[1]; // \"b\" slice 方法slice 方法用于从原字符串取出子字符串并返回，不改变原字符串。它的第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。 123456789\"JavaScript\".slice(0, 4); // \"Java\"//如果省略第二个参数，则表示子字符串一直到原字符串结束。\"JavaScript\".slice(4); // \"Script\"//如果参数是负值，表示从结尾开始倒数计算的位置，即该负值加上字符串长度。\"JavaScript\".slice(-6); // \"Script\"\"JavaScript\".slice(0, -6); // \"Java\"\"JavaScript\".slice(-2, -1); // \"p\"//如果第一个参数大于第二个参数，slice方法返回一个空字符串。\"JavaScript\".slice(2, 1); // substring 方法substring 方法用于从原字符串取出子字符串并返回，不改变原字符串，跟 slice 方法很相像。它的第一个参数表示子字符串的开始位置，第二个位置表示结束位置（返回结果不含该位置）。 1234567\"JavaScript\".substring(0, 4); // \"Java\"//如果省略第二个参数，则表示子字符串一直到原字符串的结束。\"JavaScript\".substring(4); // \"Script\"//如果第二个参数大于第一个参数，substring方法会自动更换两个参数的位置。\"JavaScript\".substring(10, 4); // \"Script\"// 等同于\"JavaScript\".substring(4, 10); // \"Script\" substr 方法substr 方法用于从原字符串取出子字符串并返回，不改变原字符串，跟 slice 和 substring 方法的作用相同。substr 方法的第一个参数是子字符串的开始位置（从 0 开始计算），第二个参数是子字符串的长度。 1234567\"JavaScript\".substr(4, 6); // \"Script\"//如果省略第二个参数，则表示子字符串一直到原字符串的结束。\"JavaScript\".substr(4); // \"Script\"//如果第一个参数是负数，表示倒数计算的字符位置。如果第二个参数是负数，将被自动转为0，因此会返回空字符串。\"JavaScript\".substr(-6); // \"Script\"\"JavaScript\".substr(4, -1); // \"\"//上面代码中，第二个例子的参数-1自动转为0，表示子字符串长度为0，所以返回空字符串 indexOf 方法indexOf 方法用于确定一个字符串在另一个字符串中第一次出现的位置，返回结果是匹配开始的位置。如果返回-1，就表示不匹配。 12345678\"hello world\".indexOf(\"o\"); // 4\"JavaScript\".indexOf(\"script\"); // -1//indexOf方法还可以接受第二个参数，表示从该位置开始向后匹配。\"hello world\".indexOf(\"o\", 6); // 7//lastIndexOf方法的用法跟indexOf方法一致，主要的区别是lastIndexOf从尾部开始匹配，indexOf则是从头部开始匹配。\"hello world\".lastIndexOf(\"o\"); // 7//另外，lastIndexOf的第二个参数表示从该位置起向前匹配。\"hello world\".lastIndexOf(\"o\", 6); // 4 trim 方法trim 方法用于去除字符串两端的空格，返回一个新字符串，不改变原字符串。 1234\"hello world\".trim();// \"hello world\"//该方法去除的不仅是空格，还包括制表符（\\t、\\v）、换行符（\\n）和回车符（\\r）。\"\\r\\nabc \\t\".trim(); // 'abc' toLowerCase 方法toLowerCase 方法用于将一个字符串全部转为小写，toUpperCase 则是全部转为大写。它们都返回一个新字符串，不改变原字符串。 1234\"Hello World\".toLowerCase();// \"hello world\"\"Hello World\".toUpperCase();// \"HELLO WORLD\" replace 方法replace 方法用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有 g 修饰符的正则表达式）。 12\"aaa\".replace(\"a\", \"b\"); // \"baa\"\"aaa\".replace(/a/g, \"b\"); // \"bbb\" split 方法split 方法按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。 123\"a|b|c\".split(\"|\"); // [\"a\", \"b\", \"c\"]//如果分割规则为空字符串，则返回数组的成员是原字符串的每一个字符。\"a|b|c\".split(\"\"); // [\"a\", \"|\", \"b\", \"|\", \"c\"] ASCII 码和字符集字符串常见 API(charCodeAt\\fromCharCode)charCodeAt方法返回字符串指定位置的 Unicode 码点（十进制表示），相当于String.fromCharCode()的逆操作。&#39;abc&#39;.charCodeAt(1) // 98上面代码中，abc 的 1 号位置的字符是 b，它的 Unicode 码点是 98。String.fromCharCode()String 对象提供的静态方法（即定义在对象本身，而不是定义在对象实例的方法），主要是String.fromCharCode()。该方法的参数是一个或多个数值，代表 Unicode 码点，返回值是这些码点组成的字符串。 1234String.fromCharCode(); // \"\"String.fromCharCode(97); // \"a\"String.fromCharCode(104, 101, 108, 108, 111);// \"hello\" 统计字符串中每个字符的个数 本文作者：人模人样的搬砖老段本文链接：关于 ES5 和字符串 string如有错误，请及时评论或者知乎私信或者 B 站私信哦~ 最后更新于:2020/04/13","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"ES5","slug":"ES5","permalink":"http://yoursite.com/tags/ES5/"},{"name":"string","slug":"string","permalink":"http://yoursite.com/tags/string/"}]},{"title":"Math和Date","date":"2019-06-30T11:12:52.000Z","path":"2019/06/30/Math和Date/","text":"MathMath 是 JavaScript 的原生对象，提供各种数学功能。该对象不是构造函数，不能生成实例，所有的属性和方法都必须在 Math 对象上调用。 Math 对象的属性，提供以下一些数学常数。（了解）Math.E：常数 e。Math.PI：常数 Pi。 Math.abs方法返回参数值的绝对值。 12Math.abs(1); // 1Math.abs(-1); // 1 Math.max 方法返回参数之中最大的那个值，Math.min 返回最小的那个值。如果参数为空, Math.min 返回 Infinity, Math.max 返回-Infinity。 Infinity 用于存放表示正无穷大的数值 1234Math.max(2, -1, 5); // 5Math.min(2, -1, 5); // -1Math.min(); // InfinityMath.max(); // -Infinity Math.floor方法小于参数值的最大整数（地板值）。 12345Math.floor(3.2); // 3Math.floor(-3.2); // -4//Math.ceil方法返回大于参数值的最小整数（天花板值）。Math.ceil(3.2); // 4Math.ceil(-3.2); // -3 Math.round方法用于四舍五入。 123456Math.round(0.1); // 0Math.round(0.5); // 1Math.round(0.6); // 1Math.round(-1.1); // -1Math.round(-1.5); // -1Math.round(-1.6); // -2 Math.pow方法返回以第一个参数为底数、第二个参数为幂的指数值。 1234// 等同于 2 ** 2Math.pow(2, 2); // 4// 等同于 2 ** 3Math.pow(2, 3); // 8 Math.sqrt方法返回参数值的平方根。如果参数是一个负值，则返回 NaN。 12Math.sqrt(4); // 2Math.sqrt(-4); // NaN 勾股定理a^2+b^2=c^2 三角函数Math 对象还提供一系列三角函数方Math.sin()：返回参数的正弦（参数为弧度值）Math.cos()：返回参数的余弦（参数为弧度值）Math.tan()：返回参数的正切（参数为弧度值）30*Math.PI/180 角度转为弧度 1234Math.sin(0); // 0Math.cos(0); // 1Math.tan(0); // 0Math.sin(Math.PI / 2); // 1 **Math.random()**返回 0 到 1 之间的一个伪随机数，可能等于 0，但是一定小于 1。 1Math.random(); // 0.7151307314634323 任意范围的随机整数生成函数如下。 1234function getRandomInt(min, max) &#123; return parseInt(Math.random() * (max - min + 1)) + min;&#125;getRandomInt(1, 6); // 5 DateDate 对象是 JavaScript 原生的时间库。它以 1970 年 1 月 1 日 00:00:00 作为时间的零点，可以表示的时间范围是前后各 1 亿天（单位为毫秒）日期对象创建Date 可以当作构造函数使用。对它使用 new 命令，会返回一个 Date 对象的实例。如果不加参数，实例代表的就是当前时间。 123456var today = new Date();today;// \"Tue Dec 01 2015 09:34:43 GMT+0800 (CST)\"// 等同于today.toString();// \"Tue Dec 01 2015 09:34:43 GMT+0800 (CST)\" 对 Date 实例求值，返回的是一个字符串，代表该实例对应的时间。 日期处理oDate.getDate() 返回一个月中的某一天 (1 ~ 31)oDate.getDay() 返回一周中的某一天 (0 ~ 6)oDate.getMonth() 返回月份 (0 ~ 11)oDate.getFullYear() 以四位数字返回年份 作为构造函数时，Date 对象可以接受多种格式的参数，返回一个该参数对应的时间实例。 1234567// 参数为时间零点开始计算的毫秒数new Date(1378218728000)（最常用）// Tue Sep 03 2013 22:32:08 GMT+0800 (CST)/ 参数为多个整数，// 代表年、月、日、小时、分钟、秒、毫秒new Date(2013, 0, 1, 0, 0, 0, 0)// Tue Jan 01 2013 00:00:00 GMT+0800 (CST) 参数也可以是一个字符串（最常用）日期字符串应该符合 RFC 2822 和 ISO 8061 这两个标准，即 YYYY-MM-DDTHH:mm:ss.sssZ 格式 12345678new Date(\"2013-2-15\");new Date(\"2013/2/15\");new Date(\"02/15/2013\");new Date(\"2013-FEB-15\");new Date(\"FEB, 15, 2013\");new Date(\"Feberuary, 15, 2013\");new Date(\"15 Feb 2013\");new Date(\"15, Feberuary, 2013\"); 上面多种日期字符串的写法，返回的都是同一个时间 日期处理oDate.getDate() 返回一个月中的某一天 (1 ~ 31)oDate.getDay() 返回一周中的某一天 (0 ~ 6)oDate.getMonth() 返回月份 (0 ~ 11)oDate.getFullYear() 以四位数字返回年份oDate.getHours() 返回当前小时（0-23）oDate.getMinutes() 返回当前分钟 (0 ~ 59)oDate.getSeconds() 返回当前秒(0 ~ 59)oDate.getMillisenconds() 返回当前毫秒(0 ~ 999)注意，月份从 0 开始计算，但是，天数从 1 开始计算。另外，除了日期的默认值为 1，小时、分钟、秒钟和毫秒的默认值都是 0。 12new Date(2013, 15);// Tue Apr 01 2014 00:00:00 GMT+0800 (CST) oDate.getTime() 返回 1970 年 1 月 1 日至今的毫秒数oDate.setDate() 设置月中的某一天 (1 ~ 31)oDate.setMonth() 设置月份 (0 ~ 11)例： 12oDate.setMonth(9);alert(oDate.getMonth()); oDate.setFullYear() 设置年份（四位数）oDate.setHours() 设置小时（0-23）oDate.setMinutes() 设置分钟 (0 ~ 59)oDate.setSeconds() 设置秒(0 ~ 59)oDate.setMillisenconds() 设置毫秒(0 ~ 999)oDate.setTime() 设置 1970 年 1 月 1 日至今的毫秒数这些参数如果超出了正常范围，会被自动折算。比如，如果月设为 15，就折算为下一年的 4 月 日期的运算类型自动转换时，Date 实例如果转为数值，则等于对应的毫秒数；如果转为字符串，则等于对应的日期字符串。所以，两个日期实例对象进行减法运算时，返回的是它们间隔的毫秒数；进行加法运算时，返回的是两个字符串连接而成的新字符串。 123456var d1 = new Date(2000, 2, 1);var d2 = new Date(2000, 3, 1);d2 - d1;// 2678400000d2 + d1;// \"Sat Apr 01 2000 00:00:00 GMT+0800 (CST)Wed Mar 01 2000 00:00:00 静态方法Date.parse方法用来解析日期字符串，返回该时间距离时间零点（1970 年 1 月 1 日 00:00:00）的毫秒数。日期字符串应该符合 RFC 2822 和 ISO 8061 这两个标准，即 YYYY-MM-DDTHH:mm:ss.sssZ 格式，其中最后的 Z 表示时区。但是，其他格式也可以被解析，请看下面的例子。 123456Date.parse(\"Aug 9, 1995\");Date.parse(\"January 26, 2011 13:51:50\");Date.parse(\"Mon, 25 Dec 1995 13:30:00 GMT\");Date.parse(\"Mon, 25 Dec 1995 13:30:00 +0430\");Date.parse(\"2011-10-10\");Date.parse(\"2011-10-10T14:48:00\"); 定时器setInterval(func,time)有两个参数，第一个参数是一个函数，第二个参数是时间间隔，单位是毫秒每间隔 time 毫秒，会执行一次函数setInterval 的返回值是一个数字 1234function box() &#123; console.log(1);&#125;var timer = setInerval(box, 1000); 上面代码意思是，没间隔 1000 毫秒，box 函数执行一次。取消定时器的执行如果想要取消定时器的执行我们需要拿到 setInerval 定时器函数的返回值，调用 clearInterval，清除定时器clearInterval(timer)，调用之后 box 函数就不会再执行了！ 本文作者：人模人样的搬砖老段本文链接：Math 和 Date如有错误，请及时评论或者知乎私信或者 B 站私信哦~ 最后更新于:2020/02/06","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Math","slug":"Math","permalink":"http://yoursite.com/tags/Math/"},{"name":"Date","slug":"Date","permalink":"http://yoursite.com/tags/Date/"}]},{"title":"BOM和DOM","date":"2019-06-16T02:20:31.000Z","path":"2019/06/16/BOM和DOM/","text":"BOMBOM 的概念提供了独立于页面内容而与浏览器进行交互的对象，其核心对象是 window在浏览器中，window 对象（注意，w 为小写）指当前的浏览器窗口。它也是所有对象的顶层对象。“顶层对象”指的是最高一层的对象，所有其他对象都是它的下属。JavaScript 规定，浏览器环境的所有全局变量，都是 window 对象的属性。 12var a = 1;window.a; // 1 上面代码中，变量 a 是一个全局变量，但是实质上它是 window 对象的属性。声明一个全局变量，就是为 window 对象的同名属性赋值 浏览器代理检测，可以检测出来用户使用的浏览器类型，也可以检测浏览器所在的操作系统navigator.userAgent判断浏览器类型 123456789101112var t = navigator.userAgent;if (t.indexOf(\"Trident\") != -1) &#123; console.log(\"ie内核\");&#125; else if (t.indexOf(\"Presto\") != -1) &#123; console.log(\"欧朋\");&#125; else if (t.indexOf(\"Chrome\") != -1) &#123; console.log(\"chrome \");&#125; else if (t.indexOf(\"Safari\") != -1) &#123; console.log(\"Safari \");&#125; else &#123; console.log(\"其他\");&#125; 判断是移动端还是 PC（重要） 123456789//移动端var ua = navigator.userAgent.toLowerCase();if (ua.indexOf(\"mobi\") != -1) &#123; // 手机浏览器 console.log(\"手机\");&#125; else &#123; // 非手机浏览器 console.log(\"非手机\");&#125; 并且判断是安卓还是苹果 1234567891011121314151617var ua = navigator.userAgent.toLowerCase();if (ua.indexOf(\"mobi\") != -1) &#123; // 手机浏览器 console.log(\"手机\"); if (ua.indexOf(\"android\") != -1) &#123; console.log(\"移动端 安卓\"); &#125; else if ( ua.indexOf(\"ipod\") != -1 || ua.indexOf(\"iphone\") != -1 || ua.indexOf(\"ipad\") != -1 ) &#123; console.log(\"移动端 苹果手机\"); &#125;&#125; else &#123; // 非手机浏览器 console.log(\"非手机\");&#125; location 对象location 对象包含有关当前 URL 的信息。location 对象是 Window 对象的一个部分，可通过 window.location 属性来访问。 属性：hash、host、hostname、href、pathname、port、protocol、searchhref：设置或返回完整的 URL。（常用）hash：设置或返回从井号 (#) 开始的 URL（锚）。search：设置或返回从问号 (?) 开始的 URL（查询部分？id=1&amp;name=abb）。（常用） host 设置或返回主机名和当前 URL 的端口号。hostname 设置或返回当前 URL 的主机名。pathname 设置或返回当前 URL 的路径部分。port 设置或返回当前 URL 的端口号。protocol 设置或返回当前 URL 的协议。 location 对象方法：assign(url), replace(url) , reload()assign() 加载新的文档。reload() 重新加载当前文档。replace() 用新的文档替换当前文档。 window.open();打开一个新的浏览器窗口。window.close();关闭浏览器窗口。 alert(arg1)显示带有一段消息和一个确认按钮的警告框。 prompt(arg1,arg2)显示可提示用户输入的对话框。 confirm(arg1) （偶尔）显示带有一段消息以及确认按钮和取消按钮的对话框。 history 对象：history 对象保存着用户上网的历史记录,从窗口被 打开的那一刻算起.后退一页 history.go(-1) history.back()前进一页 history.go(1) history.forward()前进两页 history.go(2) window.onloadload 事件发生在文档在浏览器窗口加载完毕时。window.onload 属性可以指定这个事件的回调函数。 123window.onload = function () &#123; console.log(\"页面加载完毕\");&#125;; 定时器和延时器JavaScript 提供定时执行代码的功能，叫做定时器（timer），主要由 setTimeout()和 setInterval()这两个函数来完成。 延时器setTimeout 函数用来指定某个函数或某段代码，在多少毫秒之后执行。它返回一个整数，表示定时器的编号，以后可以用来取消这个定时器。var timerId = setTimeout(func, delay);上面代码中，setTimeout 函数接受两个参数，第一个参数 func 是将要推迟执行的函数名，第二个参数 delay 是推迟执行的毫秒数。 123456console.log(1);//推迟执行setTimeout(function () &#123; console.log(2);&#125;, 1000);console.log(3); setInterval 函数的用法与 setTimeout 完全一致，区别仅仅在于 setInterval 指定某个任务每隔一段时间就执行一次，也就是无限次的定时执行。 123var timer = setInterval(function () &#123; console.log(2);&#125;, 1000); 上面代码中，每隔 1000 毫秒就输出一个 2，会无限运行下去，直到关闭当前窗口。 清除定时器setTimeout 和 setInterval 函数，都返回一个整数值，表示计数器编号。将该整数传入 clearTimeout 和 clearInterval 函数，就可以取消对应的定时器。 1234var id1 = setTimeout(f, 1000);var id2 = setInterval(f, 1000);clearTimeout(id1);clearInterval(id2); 上面代码中，回调函数 f 不会再执行了，因为两个定时器都被取消了。 window.onscroll可以监听页面的滚动 123window.onscroll = function () &#123; console.log(\"页面滚动\");&#125;; 一旦页面滚动就会触发 onscroll 函数 DOMdocument.scrollingElementdocument.scrollingElement 属性返回文档的滚动元素。也就是说，当文档整体滚动时，到底是哪个元素在滚动。这个属性返回的文档的根元素 document.documentElement（即&lt;html&gt;）。获取可视区域距离页面顶部的距离document.scrollingElement.scrollTop;设置滚动条的距离页面顶面的距离document.scrollingElement.scrollTop = 0或者也可以像下面获取 12scrollTop = document.scrollingElement.scrollTop;scrollTop = document.documentElement.scrollTop || document.body.scrollTop; 设置 12document.documentElement.scrollTop = 0document.body.scrollTop = 0； DOM 的概念及作用DOM 是 JavaScript 操作网页的 api 接口，全称为“文档对象模型”（Document Object Model）。它的作用是将网页转为一个 JavaScript 对象，从而可以用脚本进行各种操作（比如增删内容）。 浏览器会根据 DOM 模型，将结构化文档（比如 HTML 和 XML）解析成一系列的节点，再由这些节点组成一个树状结构（DOM Tree）。所有的节点和最终的树状结构，都有规范的对外接口。 DOM 只是一个接口规范，可以用各种语言实现。所以严格地说，DOM 不是 JavaScript 语法的一部分，但是 DOM 操作是 JavaScript 最常见的任务，离开了 DOM，JavaScript 就无法控制网页。另一方面，JavaScript 也是最常用于 DOM 操作的语言。后面介绍的就是 JavaScript 对 DOM 标准的实现和用法。节点树一个文档的所有节点，按照所在的层级，可以抽象成一种树状结构。这种树状结构就是 DOM 树。它有一个顶层节点，下一层都是顶层节点的子节点，然后子节点又有自己的子节点，就这样层层衍生出一个金字塔结构，倒过来就像一棵树。 浏览器原生提供 document 节点，代表整个文档。 DOM 的基本操作(查询、创建、添加，修改，删除) document.getElementById方法返回匹配指定 id 属性的元素节点。如果没有发现匹配的节点，则返回 null。 document.getElementsByClassName方法返回一个类似数组的对象（HTMLCollection 实例），包括了所有 class 名字符合指定条件的元素 document.getElementsByTagName方法搜索 HTML 标签名，返回符合条件的元素。它的返回值是一个类似数组对象（HTMLCollection 实例） document.querySelector方法接受一个 CSS 选择器作为参数，返回匹配该选择器的元素节点。如果有多个节点满足匹配条件，则返回第一个匹配的节点。如果没有发现匹配的节点，则返回 null。 1var el1 = document.querySelector(\".myclass\"); document.querySelectorAll方法与 querySelector 用法类似，区别是返回一个 NodeList 对象，包含所有匹配给定选择器的节点。 1elementList = document.querySelectorAll(\".myclass\"); document.createElement方法用来生成元素节点，并返回该节点。 1var newDiv = document.createElement(\"div\"); createElement 方法的参数为元素的标签名，即元素节点的 tagName 属性，对于 HTML 网页大小写不敏感，即参数为 div 或 DIV 返回的是同一种节点 **oDiv.appendChild(newDiv);**把 newDiv 添加到 oDiv 内部的最后面Element.innerHTML属性返回一个字符串，等同于该元素包含的所有 HTML 代码。该属性可读写，常用来设置某个节点的内容。它能改写所有元素节点的内容，包括&lt;HTML&gt;和&lt;body&gt;元素。如果将 innerHTML 属性设为空，等于删除所有它包含的所有节点。 box.replaceChild(newNode,oldNode) 12var el = document.getElementById(\"mydiv\");el.remove(); DOM 节点类型(元素和文本)DOM 的最小组成单位叫做节点（node）。文档的树形结构（DOM 树），就是由各种不同类型的节点组成。每个节点可以看作是文档树的一片叶子。 Element：网页的各种 HTML 标签（比如&lt;body&gt;、&lt;a&gt;等） Text：标签之间或标签包含的文本 （创建 Text） 注释也是节点 通过 nodeType 属性可以查看类型如果节点是一个元素节点，nodeType 属性返回 1。如果节点是属性节点, nodeType 属性返回 2。如果节点是一个文本节点，nodeType 属性返回 3。如果节点是一个注释节点，nodeType 属性返回 8 文档碎片 document.createDocumentFragment() 作为容器使用，可以避免频繁操作 dom 本文作者：人模人样的搬砖老段本文链接：BOM 和 DOM如有错误，请及时评论或者知乎私信或者 B 站私信哦~ 最后更新于:2020/02/02","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"BOM","slug":"BOM","permalink":"http://yoursite.com/tags/BOM/"},{"name":"DOM","slug":"DOM","permalink":"http://yoursite.com/tags/DOM/"}]},{"title":"DOM补充","date":"2019-06-02T15:50:09.000Z","path":"2019/06/02/DOM补充/","text":"DOM 属性节点 Element.classNameclassName 属性用来读写当前元素节点的 class 属性。它的值是一个字符串，每个 class 之间用空格分割。 1234// HTML 代码 &lt;div class=\"one two three\" id=\"myDiv\"&gt;&lt;/div&gt;var div = document.getElementById(\"myDiv\");div.className;// \"one two three\" Element.style每个元素节点都有 style 用来读写该元素的行内样式信息不过，连词号需要变成骆驼拼写法。 1234567891011var divStyle = document.querySelector(\"div\").style;divStyle.backgroundColor = \"red\";divStyle.border = \"1px solid black\";divStyle.width = \"100px\";divStyle.height = \"100px\";divStyle.fontSize = \"10em\";divStyle.backgroundColor; // reddivStyle.border; // 1px solid blackdivStyle.height; // 100pxdivStyle.width; // 100px Element.style返回的只是行内样式，并不是该元素的全部样式。通过样式表设置的样式，或者从父元素继承的样式，无法通过这个属性得到。元素的全部样式要通过window.getComputedStyle()得到。 获取属性和设置属性（自定义属性） Element.getAttribute方法接受一个字符串作为参数，返回同名属性的值。如果没有该属性，则返回 null。 12var mydiv = document.getElementById(\"mydiv\");var id = mydiv.getAttribute(\"id\"); Element.setAttribute方法用于为当前节点设置属性。如果属性已经存在，将更新属性值，否则将添加该属性。该方法没有返回值。 12345// HTML 代码为// &lt;button&gt;Hello World&lt;/button&gt;var b = document.querySelector(\"button\");b.setAttribute(\"name\", \"myButton\");b.setAttribute(\"disabled\", true); Element.removeAttribute方法移除指定属性。该方法没有返回值。 1document.getElementById(\"div1\").removeAttribute(\"id\"); outerHTML 包括整个标签，而不仅限于标签内部的内容innerText 只获取元素内的文本内容，html 标签将被忽略 获取孩子节点 childNodes 和 childrenElement.children属性返回一个类似数组的对象（HTMLCollection 实例），包括当前元素节点的所有子元素。如果当前元素没有子元素，则返回的对象包含零个成员 这个属性与Node.childNodes属性的区别是，它只包括元素类型的子节点，不包括其他类型的子节点。而 childNodes 属性包含空白节点 高级选取Element.firstElementChild属性返回当前元素的第一个元素子节点，Element.lastElementChild返回最后一个元素子节点。如果没有元素子节点，这两个属性返回 null。 nextElementSibling 下一个节点 previousElementSibling 上一个节点 Element.nextElementSibling属性返回当前元素节点的后一个同级元素节点，如果没有则返回 null。 Element.previousElementSibling属性返回当前元素节点的前一个同级元素节点，如果没有则返回 null。 （分别对应的还有 firstChild，lastChild，nextSibling ，previousSibling 方法 不过这些个方法都能获取到文本节点） Element.parentNode可以获取父节点 获取全部样式元素的全部样式要通过window.getComputedStyle()得到。 行内样式（inline style）具有最高的优先级，改变行内样式，通常会立即反映出来。但是，网页元素最终的样式是综合各种规则计算出来的。因此，如果想得到元素实际的样式，只读取行内样式是不够的，需要得到浏览器最终计算出来的样式规则。 window.getComputedStyle方法，就用来返回浏览器计算后得到的最终规则。它接受一个节点对象作为参数，返回一个 CSSStyle 实例，包含了指定节点的最终样式信息。所谓“最终样式信息”，指的是各种 CSS 规则叠加后的结果。 123var div = document.querySelector('div');var styleObj = window.getComputedStyle(div);(只能获取样式，不能设置)styleObj.backgroundColor 上面代码中，得到的背景色就是 div 元素真正的背景色 兼容性问题低版本 ie 使用box.currentStyle 获取全部样式 box.insertBefore(newNode, existNode) 插入节点 在 box 的子节点 existNode 前面插入一个新节点 document.createTextNode() 创建文本节点 12var t = document.createTextNode(\"你好\");box.appendChild(t); 在 box 尾部添加一个文本节点 offsetWidth/offsetHeightElement.offsetHeight属性返回一个整数，表示元素的 CSS 垂直高度（单位像素），包括元素本身的高度、padding 和 border Element.offsetWidth属性表示元素的 CSS 水平宽度（单位像素），其他都与Element.offsetHeight一致。这两个属性都是只读属性 如果元素的 CSS 设为不可见（比如 display: none;），则返回 0 Element.offsetParent属性返回最靠近当前元素的、并且 CSS 的 position 属性不等于 static 的上层元素。 12345&lt;div style=\"position: absolute;\"&gt; &lt;p&gt; &lt;span&gt;Hello&lt;/span&gt; &lt;/p&gt;&lt;/div&gt; 上面代码中，span 元素的 offsetParent 属性就是 div 元素。 该属性主要用于确定子元素位置偏移的计算基准，Element.offsetTop和Element.offsetLeft就是offsetParent元素计算的。 offsetLeft/offsetTopElement.offsetLeft返回当前元素左上角相对于Element.offsetParent节点的水平位移，Element.offsetTop返回垂直位移，单位为像素。通常，这两个值是指相对于父节点的位移 本文作者：人模人样的搬砖老段本文链接：DOM 补充如有错误，请及时评论或者知乎私信或者 B 站私信哦~ 最后更新于:2020/02/02","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"DOM","slug":"DOM","permalink":"http://yoursite.com/tags/DOM/"}]},{"title":"事件Event","date":"2019-05-19T12:31:33.000Z","path":"2019/05/19/事件Event-一/","text":"事件基础JavaScript 事件是由访问 Web 页面的用户引起的一系列操作。当用户执行某些操作的时候，再去执行一系列代码。或者用来获取事件详细信息，如鼠标位置、键盘按键等。 事件处理函数javaScript 可以处理的事件类型为：鼠标事件、键盘事件、HTML 事件所有的事件处理函数都会都有两个部分组成，on + 事件名称 鼠标事件onclick:用户单击鼠标按钮ondblclick:当用户双击主鼠标按钮时触发onmousedown:当用户按下鼠标还未弹起时触发onmouseup：当用户释放鼠标按钮时触发onmouseover：当鼠标移到某个元素上方时触发onmouseout：当鼠标移出某个元素上方时触发onmousemove：当鼠标指针在元素上移动时触发 HTML 事件onload：当页面或者资源完全加载后在 window 上面触发onselect：当用户选择文本框(input 或 textarea)中的一个或多个字符触发onchange：当文本框(input 或 textarea)内容改变且失去焦点后触发onfocus：当页面或者元素获得焦点时在 window 及相关元素上面触发onblur：当页面或元素失去焦点时在 window 及相关元素上触发onresize：当窗口或框架的大小变化时在 window 或框架上触发onscroll：当用户滚动带滚动条的元素时触发 事件对象当触发某个事件时，会产生一个事件对象，这个对象包含着所有与事件有关的信息 。包括导致事件的元素、事件的类型、以及其它与特定事件相关的信息。 通过事件绑定的执行函数是可以得到一个隐藏参数的 。说明，浏览器会自动分配一个参数，这个参数其实就是 event 对象。 Event 对象获取方式 （兼容性） 123el.onclick = function (evt) &#123; let e = evt || window.event;&#125;; event.button 属性当前事件触发时哪个鼠标按键被点击clientX、clientY 属性鼠标在可视区 X 坐标和 Y 坐标，即距离左边框和上边框的距离screenX、screenY 属性鼠标在屏幕区 X 坐标和 Y 坐标，即距离左屏幕和上屏幕的距离offsetX、offsetY 属性鼠标相对于事件源的 X 坐标和 Y 坐标pageX、pageY鼠标相对于文档的 X 坐标和 Y 坐标 键盘事件onkeydown：当用户按下键盘上任意键触发，如果按住不放，会重复触发onkeypress：当用户按下键盘上的字符键触发，如果按住不放，会重复触发onkeyup：当用户释放键盘上的键触发组合键 ctrkey、altkey、shiftkeyaltKey 属性，bool 类型，表示发生事件的时候 alt 键是否被按下ctrlKey 属性，bool 类型，表示发生事件的时候 ctrl 键是否被按下shiftKey 属性，bool 类型，表示发生事件的时候 shift 键是否被按下 keyCode/which 兼容事件源（事件在哪个元素上产生） 冒泡 事件的冒泡事件按照从最特定的事件目标到最不特定的事件目标(document 对象)的顺序触发。 阻止事件冒泡 1234//阻止事件冒泡e.stopPropagation();//低版本iee.cancelBubble = true; 事件默认行为及阻止方式 浏览器的默认行为JavaScript 事件本身所具有的属性，例如 a 标签的跳转，Submit 按钮的提交，右键菜单，文本框的输入等。 阻止默认行为的方式w3c 的方法是e.preventDefault()， IE 则是使用e.returnValue = false; return false; 自定义右键菜单 oncontextmenu DOM2 级事件处理程序添加事件监听器：ele.addEventListener(事件名,处理函数,布尔值)现代浏览器（IE9、10、11 | ff, chorme, safari, opera）注意：事件名不带 on，处理函数为函数引用，布尔值代表冒泡(内到外)或捕获（外到内） 12element.addEventListener(\"click\", function () &#123;&#125;, false); //false 事件冒泡element.addEventListener(\"click\", function () &#123;&#125;, true); //true事件捕获 移除事件监听器：removeEventListener(事件名,处理函数) IE8 及以下的事件监听器：attachEvent(事件名,处理函数)，detachEvent(事件名,处理函数)注意：事件名带 on 事件委托利用事件冒泡的原理，把本应添加给某元素上的事件委托给他的父级（外层）。 使用案例如果一个 ul 中有很多 li，循环遍历所有的 li，给 li 添加事件效率比较低，我们可以监听 ul 的点击事件，利用子元素的点击事件都会冒泡到父元素的特点，就可以知道什么时候点击了 li。 好处：效率高，可以给未来元素添加事件 事件对象中的拖拽效果拖拽原理三个事件：onmousedown、onmousemove、onmouseup 实现思路： 给目标元素添加 onmousedown 事件，拖拽的前提是在目标元素按下鼠标左键。 当 onmousedown 发生以后，此刻给 document 添加 onmousemove 事件，意味着此刻鼠标在网页的移动都将改变目标元素的位置。 在 onmousemove 事件中，设定目标元素的 left 和 top，公式：目标元素的 left = 鼠标的 clientX - (鼠标和元素的横坐标差，即 offsetX)目标元素的 top = 鼠标的 clientY - (鼠标和元素的纵坐标差，即 offsetY) 当 onmousedown 发生以后，此刻给 document 添加 onmouseup 事件，意味着此刻鼠标在网页的任意位置松开鼠标，都会放弃拖拽的效果。 在 onmouseup 事件中，取消 document 的 onmousemove 事件即可。 本文作者：人模人样的搬砖老段本文链接：事件 Event如有错误，请及时评论或者知乎私信或者 B 站私信哦~ 最后更新于:2020/02/02","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"事件","slug":"事件","permalink":"http://yoursite.com/tags/%E4%BA%8B%E4%BB%B6/"}]},{"title":"正则","date":"2019-05-05T11:57:59.000Z","path":"2019/05/05/正则/","text":"正则的概念正则表达式(regular expression)是一个描述字符规则的对象。可以用来检查一个字符串是否含有某个子字符串，将匹配的子字符串做替换或者从某个字符串中取出符合某个条件的子串等。为什么要用正则：前端往往有大量的表单数据校验工作，采用正则表达式会使得数据校验的工作量大大减轻。常用效果：邮箱、手机号、身份证号等。 创建方式 第一种方式 1var reg = new RegExp(\"study\"，\"ig\"); // 第二个参数为修饰符 i：表示忽略大小写 ignore。g：表示全局匹配，查找所有匹配而非在找到第一个匹配后停止 global。 第二种方式 1var reg = /study/gi; 正则对象方法 test： 正则实例对象的 test 方法返回一个布尔值，表示当前模式是否能匹配参数字符串 1/cat/.test(\"cats and dogs\"); // true 上面代码验证参数字符串之中是否包含 cat，结果返回 true。如果正则表达式带有 g 修饰符，则每一次 test 方法都从上一次结束的位置开始向后匹配 1234567891011var r = /x/g;var s = \"_x_x\";r.lastIndex; // 0r.test(s); // truer.lastIndex; // 2r.test(s); // truer.lastIndex; // 4r.test(s); // false 上面代码的正则表达式使用了 g 修饰符，表示是全局搜索，会有多个结果。接着，三次使用 test 方法，每一次开始搜索的位置都是上一次匹配的后一个位置。 带有 g 修饰符时，可以通过正则对象的 lastIndex 属性指定开始搜索的位置 12345var r = /x/g;var s = \"_x_x\";r.lastIndex = 4;r.test(s); // false 上面代码指定从字符串的第五个位置开始搜索，这个位置是没有字符的，所以返回 false。 exec：用于检索字符串中的正则表达式的匹配。返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。 123456var s = \"_x_x\";var r1 = /x/;var r2 = /y/;r1.exec(s); // [\"x\"]r2.exec(s); // null 上面代码中，正则对象 r1 匹配成功，返回一个数组，成员是匹配结果；正则对象 r2 匹配失败，返回 null。 字符串函数 replace： 按照给定的正则表达式进行替换，返回替换后的字符串。字符串对象的 replace 方法可以替换匹配的值。它接受两个参数，第一个是正则表达式，表示搜索模式，第二个是替换的内容。 1str.replace(search, replacement); 正则表达式如果不加 g 修饰符，就替换第一个匹配成功的值，否则替换所有匹配成功的值。 1234\"aaa\".replace(\"a\", \"b\"); // \"baa\"\"aaa\".replace(/a/, \"b\"); // \"baa\"\"aaa\".replace(/a/g, \"b\"); // \"bbb\"//上面代码中，最后一个正则表达式使用了g修饰符，导致所有的b都被替换掉了。 match： 字符串实例对象的 match 方法对字符串进行正则匹配，返回匹配结果。 123456var s = \"_x_x\";var r1 = /x/;var r2 = /y/;s.match(r1); //[\"x\"]s.match(r2); // null//从上面代码可以看到，字符串的match方法与正则对象的exec方法非常类似：匹配成功返回一个数组，匹配失败返回null。 如果正则表达式带有 g 修饰符，则该方法与正则对象的 exec 方法行为不同，会一次性返回所有匹配成功的结果 12345var s = \"abba\";var r = /a/g;s.match(r); // [\"a\", \"a\"]r.exec(s); // [\"a\"] search：检索与正则表达式相匹配的值。返回字符串中第一个与正则表达式相匹配的子串的起始位置。如果没有找到则返回-1。 12\"_x_x\".search(/x/); // 1//上面代码中，第一个匹配结果出现在字符串的1号位置。 正则表达式的构成大部分字符在正则表达式中，就是字面的含义，比如/a/匹配 a，/b/匹配 b。如果在正则表达式之中，某个字符只表示它字面的含义（就像前面的 a 和 b），那么它们就叫做“字面量字符”。 1/dog/.test(\"old dog\"); // true 上面代码中正则表达式的 dog，就是字面量字符，所以/dog/匹配 old dog，因为它就表示 d、o、g 三个字母连在一起。 除了字面量字符以外，还有一部分字符有特殊含义，不代表字面的意思。它们叫做“元字符”，主要有以下几个 正则表达式是由普通字符（例如字符 a 到 z）以及特殊字符（称为元字符）组成的文字模式。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。 元字符-限定符限定符可以指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。 *：匹配前面的子表达式零次或多次。 +：匹配前面的子表达式一次或多次。？：匹配前面的子表达式零次或一次。{n}：匹配确定 n 次。{n,}：至少匹配 n 次。{n, m}：最少匹配 n 次且最多匹配 m 次。 12345678910111213141516// t 出现0次或1次/t?est/.test('test') // true/t?est/.test('est') // true// t 出现1次或多次/t+est/.test('test') // true/t+est/.test('ttest') // true/t+est/.test('est') // false// t 出现0次或多次/t*est/.test('test') // true/t*est/.test('ttest') // true/t*est/.test('tttest') // true/t*est/.test('est') // true/lo&#123;2&#125;k/.test('look') // true/lo&#123;2,5&#125;k/.test('looook') // true//上面代码中，第一个模式指定o连续出现2次，第二个模式指定o连续出现2次到5次之间 元字符-字符匹配符字符匹配符用于匹配某个或某些字符。 [xyz]：字符集合。匹配所包含的任意一个字符。 123/[abc]/.test('hello world') // false/[abc]/.test('apple') // true//上面代码中，字符串hello world不包含a、b、c这三个字母中的任一个，所以返回false；字符串apple包含字母a，所以返回true [^xyz]： 表示除了 x、y、z 之外都可以匹配。 123/[^abc]/.test('hello world') // true/[^abc]/.test('bbc') // false//上面代码中，字符串hello world不包含字母a、b、c中的任一个，所以返回true；字符串bbc不包含a、b、c以外的字母，所以返回false。 [a-z]：字符范围。匹配指定范围内的任意字符。[abc]可以写成[a-c]，[0123456789]可以写成[0-9]，同理[A-Z]表示 26 个大写字母。 1/[a-z]/.test(\"b\"); // true 这样也可以：[0-9]、[0-9a-z]、[0-9a-zA-Z][0-9a-zA-Z] 表示数字 0-9，大小字母[^a-z]：表示不包含小写字母。 \\d 匹配 0-9 之间的任一数字，相当于[0-9]。\\D 匹配所有 0-9 以外的字符，相当于[^0-9]。\\w 匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_]。\\W 除所有字母、数字和下划线以外的字符，相当于[^A-Za-z0-9_]。\\s 匹配空格（包括换行符、制表符、空格符等）。\\S 匹配非空格的字符。.：匹配除”\\n”之外的任何单个字符。 元字符-定位符定位符可以将一个正则表达式固定在一行的开始或结束。也可以创建只在单词内或只在单词的开始或结尾处出现的正则表达式。^：匹配输入字符串的开始位置。$：匹配输入字符串的结束位置。 1234// test必须出现在开始位置/^test/.test('test123') // true// test必须出现在结束位置/test$/.test('new test') // true// 从开始位置到结束位置只有test/^test$/.test('test') // true/^test$/.test(\"test test\"); // false 元字符-转义符\\：用于匹配某些特殊字符。正则表达式中那些有特殊含义的元字符，如果要匹配它们本身，就需要在它们前面要加上反斜杠。比如要匹配+，就要写成+。 123/1+1/.test('1+1')// false/1\\+1/.test('1+1')// true//上面代码中，第一个正则表达式之所以不匹配，因为加号是元字符，不代表自身。第二个正则表达式使用反斜杠对加号转义，就能匹配成功。 元字符-选择匹配符|：可以匹配多个规则。竖线符号（|）在正则表达式中表示“或关系”（OR），即 cat|dog 表示匹配 cat 或 dog。 1234/11|22/.test('911') // true//上面代码中，正则表达式指定必须匹配11或22// 匹配fred、barney、betty之中的一个/fred|barney|betty/ 常用正则 邮政编码检测 1/^\\d&#123;6&#125;$/; 文件格式监测 1/^.+\\.(jpeg|png|gif|jpg)$/; 字符串首尾去空格 123var str = \" avaasdf \";var reg = /^\\s+|\\s+$/g;console.log(str.replace(reg, \"\")); 邮件格式监测 1/^\\w+[-+.]*\\w*@([a-z0-9A-Z\\u2E80-\\u9FFF]-?)+(\\.\\w&#123;2,6&#125;)+/; 手机号监测 1/^(13[0-9]|14[0-9]|15[0-9]|18[0-9]|17[0-9])\\d&#123;8&#125;$/; 身份证监测 1/(^\\d&#123;15&#125;$|^\\d&#123;18&#125;$)|^\\d&#123;17&#125;X$/; 中文监测unicode 编码中文监测 1/^[\\u2E80-\\u9FFF]+$/; 用户名监测（规则数字字母下划线-组成，3-16 位） 1/^[a-z0-9_-]&#123;3,16&#125;$/; 正则分组 什么是分组 123456789var reg = /(\\d&#123;2&#125;)/;reg.test(\"12\"); //true// 这里reg中的(/d&#123;2&#125;)就表示一个分组，匹配两位数字/*/hahaha//(ha)&#123;3&#125;/这两个表达式是等效的，但有了分组之后可以更急简洁*/ 捕获型分组 ()被正则表达式捕获(匹配)到的字符串会被暂存起来，其中，由分组捕获到的字符串会从 1 开始编号，于是我们可以引用这些字符串： 1234567var reg = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/;var dateStr = \"2018-04-18\";reg.test(dateStr); //true//引用捕获到的内容使用 $1 代表第一个分组的捕获到的内容RegExp.$1; //2018RegExp.$2; //04RegExp.$3; //18 非捕获型分组 (?:)有的时候只是为了分组并不需要捕获的情况下就可以使用非捕获型分组 12345var reg = /(?:\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/;var date = \"2012-12-21\";reg.test(date);RegExp.$1; // 12RegExp.$2; // 21 结合 replace 方法做自定义替换 1234var dateStr = \"2018/04/18\";var reg = /(\\d&#123;4&#125;)\\/(\\d&#123;2&#125;)\\/(\\d&#123;2&#125;)/;dateStr = dateStr.replace(reg, \"$1-$2-$3\"); //\"2018-04-18\"//不过这里需要注意的是/是需要用\\转义的 结合正则 exec 方法来使用通俗来说，分组就是在正则表达式中用()包起来的内容代表了一个分组 1234567891011121314var re = new RegExp(\"d(b+)(d)\", \"ig\");var str = \"cdbBdbsbdbdz\";var arr = re.exec(str);console.log(arr);/*0: \"dbBd\" 正则整体匹配到的字符1: \"bB\" 第一个小括号(分组)匹配到的字符2: \"d\" 第二个小括号（分组）匹配到的字符*/// 第一个分组的结果也可以用 RegExp.$1 获取s = \"$1 contains: \" + RegExp.$1 + \"\\n\";s += \"$2 contains: \" + RegExp.$2 + \"\\n\";console.log(s); 结合字符串 match 方法使用 1234567891011121314var str = \"http://www.taobao.com:80/cuxiao/hongbao.html\";var patt1 = /(\\w+):\\/\\/([^/:]+)(:\\d*)?([^# ]*)/;arr = str.match(patt1);console.log(arr);/*0: \"http://www.taobao.com:80/cuxiao/hongbao.html\" 整个正则匹配到的字符串1: \"http\" 第一个分组 匹配到的字符串2: \"www.taobao.com\" 第二个分组 匹配到的字符串3: \":80\" 第三个分组 匹配到的字符串4: \"/cuxiao/hongbao.html\" 第四个分组 匹配到的字符串*///第一个分组的结果也可以用 RegExp.$1 获取console.log(RegExp.$1); //http 常见面试题 12345678910111213//把url参数转对象var parseQuery = function (query) &#123; var reg = /([^=&amp;\\s]+)[=\\s]*([^&amp;\\s]*)/g; var obj = &#123;&#125;; while (reg.exec(query)) &#123; obj[RegExp.$1] = RegExp.$2; &#125; console.log(obj); return obj;&#125;;parseQuery( \"userID=JeoOrCXxyiOFxbYaGL40kw&amp;userPwd=sdFo2ziUw8HyLRKd4i6GAQ&amp;userName=aa\"); 本文作者：人模人样的搬砖老段本文链接：正则如有错误，请及时评论或者知乎私信或者 B 站私信哦~ 最后更新于:2020/02/02","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"正则","slug":"正则","permalink":"http://yoursite.com/tags/%E6%AD%A3%E5%88%99/"}]},{"title":"ES6","date":"2019-04-21T10:36:57.000Z","path":"2019/04/21/ES6/","text":"ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。 this 关键字this 可以用在构造函数之中，表示实例对象。除此之外，this 还可以用在别的场合。但不管是什么场合，this 都有一个共同点：它总是返回一个对象简单说，this 就是属性或方法“当前”所在的对象。 1234567var person = &#123; name: \"张三\", describe: function () &#123; return \"姓名：\" + this.name; &#125;,&#125;;person.describe(); // \"姓名：张三\" 上面代码中，this.name表示 name 属性所在的那个对象。由于this.name是在 describe 方法中调用，而 describe 方法所在的当前对象是 person，因此 this 指向 person，this.name就是person.name。 this 主要有以下几个使用场合 全局环境全局环境使用 this，它指的就是顶层对象 window。 123456this === window; // truefunction f() &#123; console.log(this === window);&#125;f(); // true//注：严格模式下 普通函数内部 this 等于 undefined 构造函数构造函数中的 this，指的是实例对象 1234function Person(p) &#123; this.p = p;&#125;var obj = new Person(); 对象的方法如果对象的方法里面包含 this，this 的指向就是方法运行时所在的对象。 123456var obj = &#123; foo: function () &#123; console.log(this); &#125;,&#125;;obj.foo(); // obj bind 方法bind 方法用于将函数体内的 this 绑定到某个对象，然后返回一个新函数。 1234567891011var dog = &#123; name: \"wangcai\", age: 18, wang: function () &#123; console.log(this); &#125;,&#125;;var person = &#123; name: \"小明\" &#125;;var func = dog.wang.bind(person);func();//上面代码将person绑定到了func函数内部 let/const ES6 新增了 let 命令，用来声明变量。它的用法类似于 var，但是所声明的变量，只在 let 命令所在的代码块内有效。 123456&#123; let a = 10; var b = 1;&#125;a; // ReferenceError: a is not defined.b; // 1 上面代码在代码块之中，分别用 let 和 var 声明了两个变量。然后在代码块之外调用这两个变量，结果 let 声明的变量报错，var 声明的变量返回了正确的值。这表明，let 声明的变量只在它所在的代码块有效。 for 循环的计数器，就很合适使用 let 命令。 12345678910111213141516171819202122var oLis = document.getElementsByTagName(\"li\");for (let i = 0; i &lt; oLis.length; i++) &#123; // ... oLis[i].onclick = function () &#123; console.log(i); // 0 1 2 3 4 &#125;;&#125;console.log(i);// ReferenceError: i is not defined//上面代码相当与产生了几个块级作用域&#123; var i = 0; oLis[i].onclick = function () &#123; console.log(i); &#125;;&#125;&#123; var i = 1; oLis[i].onclick = function () &#123; console.log(i); &#125;;&#125; 上面代码中，计数器 i 只在 for 循环体内有效，在循环体外引用就会报错。 ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景，let 实际上为 JavaScript 新增了块级作用域。 var 命令会发生”变量提升“现象，即变量可以在声明之前使用，值为 undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。 为了纠正这种现象，let 命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。 const 命令const 声明一个只读的常量。一旦声明，常量的值就不能改变。const 声明的变量不得改变值，这意味着，const 一旦声明变量，就必须立即初始化，不能留到以后赋值 1234const PI = 3.1415;PI; // 3.1415PI = 3;// TypeError: Assignment to constant variable. 上面代码表明改变常量的值会报错。 箭头函数ES6 允许使用“箭头”（=&gt;）定义函数。 12345var f = (v) =&gt; v;// 等同于var f = function (v) &#123; return v;&#125;; 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。 12345678910var f = () =&gt; 5;// 等同于var f = function () &#123; return 5;&#125;;var sum = (num1, num2) =&gt; num1 + num2;// 等同于var sum = function (num1, num2) &#123; return num1 + num2;&#125;; 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用 return 语句返回。 123var sum = (num1, num2) =&gt; &#123; return num1 + num2;&#125;; 箭头函数使得表达更加简洁。 12const isEven = (n) =&gt; n % 2 == 0;const square = (n) =&gt; n * n; 上面代码只用了两行，就定义了两个简单的工具函数。如果不用箭头函数，可能就要占用多行，而且还不如现在这样写醒目。 箭头函数的一个用处是简化回调函数 12345678910111213// 正常函数写法[1, 2, 3].map(function (x) &#123; return x * x;&#125;);// 箭头函数写法[1, 2, 3].map((x) =&gt; x * x);// 正常函数写法var result = values.sort(function (a, b) &#123; return a - b;&#125;);// 箭头函数写法var result = values.sort((a, b) =&gt; a - b); 箭头函数有几个使用注意点。 函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。 不可以当作构造函数，也就是说，不可以使用 new 命令，否则会抛出一个错误。 不可以使用 arguments 对象，该对象在函数体内不存在。 变量解构（解构赋值）ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构以前，为变量赋值，只能直接指定值。 123let a = 1;let b = 2;let c = 3; ES6 允许写成下面这样。 1let [a, b, c] = [1, 2, 3]; 本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值解构不仅可以用于数组，还可以用于对象 123let &#123; foo, bar &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;foo; // \"aaa\"bar; // \"bbb\" 对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值 12345let &#123; bar, foo &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;foo; // \"aaa\"bar; // \"bbb\"let &#123; foo &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;foo; // \"aaa\" 字符串扩展模板字符串（template string）是增强版的字符串 传统的 JavaScript 语言，输出模板通常是这样写的。 123456789var a = 1;var b = 2;var sum = a + b;var res = a + \"+\" + b + \"的和是&lt;b&gt;\" + c + \"&lt;/b&gt;\";console.log(res);box.innerHTML = res;var obj = &#123; name: \"zhangsan\", age: 18 &#125;;var str = \"&lt;b&gt;姓名&lt;/b&gt;：\" + obj.name + \"&lt;b&gt;年龄&lt;/b&gt;:\" + obj.age;div.innerHTML = str; 上面这种写法(拼字符串)相当繁琐不方便，ES6 引入了模板字符串解决这个问题。模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，可以在字符串中嵌入变量， 模板字符串中嵌入变量，需要将变量名写在${}之中。 123456789var a = 1;var b = 2;var sum = a + b;var res = `a+b的和是&lt;b&gt;$&#123;c&#125;&lt;/b&gt;`;console.log(res);box.innerHTML = res;var obj = &#123; name: \"zhangsan\", age: 18 &#125;;var str = `&lt;b&gt;姓名&lt;/b&gt;：$&#123;obj.name&#125;&lt;b&gt;年龄&lt;/b&gt;:$&#123;obj.age&#125;`;div.innerHTML = str; 上面代码中的模板字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义 1let greeting = `\\`Yo\\` World!`; 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中 123456oDiv.innerHTML = `&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt;&lt;/ul&gt;`; 大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。 123456789et x = 1;let y = 2;`$&#123;x&#125; + $&#123;y&#125; = $&#123;x + y&#125;`// \"1 + 2 = 3\"`$&#123;x&#125; + $&#123;y * 2&#125; = $&#123;x + y * 2&#125;`// \"1 + 4 = 5\"let obj = &#123;x: 1, y: 2&#125;;`$&#123;obj.x + obj.y&#125;` 模板字符串之中还能调用函数 123456function fn() &#123; return \"Hello World\";&#125;`foo $&#123;fn()&#125; bar`;// foo Hello World bar 字符串扩张方法传统上，JavaScript 只有 indexOf 方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。includes()：返回布尔值，表示是否找到了参数字符串。startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。 12345let s = \"Hello world!\";s.startsWith(\"Hello\"); // trues.endsWith(\"!\"); // trues.includes(\"o\"); // true repeat 方法返回一个新字符串，表示将原字符串重复 n 次 123\"x\".repeat(3); // \"xxx\"\"hello\".repeat(2); // \"hellohello\"\"na\".repeat(0); // \"\" 数组新增方法Array.from 方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（ES6 新增的数据结构 Set 和 Map）下面是一个类似数组的对象，Array.from 将它转为真正的数组 1234567let arrayLike = &#123; \"0\": \"a\", \"1\": \"b\", \"2\": \"c\", length: 3,&#125;;let arr2 = Array.from(arrayLike); // ['a', 'b', 'c'] 实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的 arguments 对象。Array.from 都可以将它们转为真正的数组 对象扩展ES6 允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。 12345const foo = \"bar\";const baz = &#123; foo &#125;;baz; // &#123;foo: \"bar\"&#125;// 等同于const baz = &#123; foo: foo &#125;; 除了属性简写，方法也可以简写。 1234567891011const o = &#123; method() &#123; return \"Hello!\"; &#125;,&#125;;// 等同于const o = &#123; method: function () &#123; return \"Hello!\"; &#125;,&#125;; 扩展运算符对象的扩展运算符（…）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。 123let z = &#123; a: 3, b: 4 &#125;;let n = &#123; ...z &#125;;n; // &#123; a: 3, b: 4 &#125; 由于数组是特殊的对象，所以对象的扩展运算符也可以用于数组。 123let foo = &#123; ...[\"a\", \"b\", \"c\"] &#125;;foo;// &#123;0: \"a\", 1: \"b\", 2: \"c\"&#125; 对象的扩展运算符等同于使用Object.assign()方法。 123let aClone = &#123; ...a &#125;;// 等同于let aClone = Object.assign(&#123;&#125;, a); 123456function add(x, y) &#123; return x + y;&#125;var numbers = [4, 38];add(...numbers); ////该运算符将一个数组，变为参数序列 12345var arr1 = [\"a\", \"b\"];var arr2 = [\"c\"];var arr3 = [\"d\", \"e\"];// 合并数组[...arr1, ...arr2, ...arr3]; 函数参数默认值ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。 1234567function log(x, y) &#123; y = y || \"World\"; console.log(x, y);&#125;log(\"Hello\"); // Hello Worldlog(\"Hello\", \"China\"); // Hello China//这种写法的缺点在于，如果参数y赋值了，但是对应的布尔值为false，则该赋值不起作用。 ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。 12345function log(x, y = \"World\") &#123; console.log(x, y);&#125;log(\"Hello\"); // Hello Worldlog(\"Hello\", \"China\"); // Hello China 可以看到，ES6 的写法比 ES5 简洁许多，而且非常自然。 Symbol 类型ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法，新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入 Symbol 的原因 ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object） Symbol 值通过 Symbol 函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突 123let s = Symbol();typeof s;// \"symbol\" 上面代码中，变量 s 就是一个独一无二的值。typeof 运算符的结果，表明变量 s 是 Symbol 数据类型，而不是字符串之类的其他类型注意，Symbol 函数前不能使用 new 命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。Symbol 函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。 123456let s1 = Symbol(\"foo\");let s2 = Symbol(\"bar\");s1; // Symbol(foo)s2; // Symbol(bar)s1.toString(); // \"Symbol(foo)\"s2.toString(); // \"Symbol(bar)\" 上面代码中，s1 和 s2 是两个 Symbol 值。如果不加参数，它们在控制台的输出都是 Symbol()，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。 注意，Symbol 函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的 Symbol 函数的返回值是不相等的。 12345678// 没有参数的情况let s1 = Symbol();let s2 = Symbol();s1 === s2; // false// 有参数的情况let s1 = Symbol(\"foo\");let s2 = Symbol(\"foo\");s1 === s2; // false 上面代码中，s1 和 s2 都是 Symbol 函数的返回值，而且参数相同，但是它们是不相等的。Symbol 值也可以转为布尔值，但是不能转为数值 123456789let sym = Symbol();Boolean(sym); // true!sym; // falseif (sym) &#123; // ...&#125;Number(sym); // TypeErrorsym + 2; // TypeError 作为属性名的 Symbol由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性，能防止某一个键被不小心改写或覆盖。 123456789// 第一种写法let a = &#123;&#125;;a[mySymbol] = \"Hello!\";// 第二种写法let a = &#123; [mySymbol]: \"Hello!\",&#125;;// 以上写法都得到同样结果a[mySymbol]; // \"Hello!\" 注意，Symbol 值作为对象属性名时，不能用点运算符。 123456const mySymbol = Symbol();const a = &#123;&#125;;a.mySymbol = \"Hello!\";a[mySymbol]; // undefineda[\"mySymbol\"]; // \"Hello!\" 上面代码中，因为点运算符后面总是字符串，所以不会读取 mySymbol 作为标识名所指代的那个值，导致 a 的属性名实际上是一个字符串，而不是一个 Symbol 值。同理，在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。 123456let s = Symbol();let obj = &#123; [s]: function (arg) &#123; ... &#125;&#125;;obj[s](123); 上面代码中，如果 s 不放在方括号中，该属性的键名就是字符串 s，而不是 s 所代表的那个 Symbol 值。 Set 和 Map 结构ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。Set 本身是一个构造函数，用来生成 Set 数据结构。 123456const s = new Set();[2, 3, 5, 4, 5, 2, 2].forEach((x) =&gt; s.add(x));for (let i of s) &#123; console.log(i);&#125;// 2 3 5 4 上面代码通过 add 方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。Set 函数可以接受一个数组（获取 dom 的 nodelist 对象）作为参数，用来初始化。 123456789101112// 例一const set = new Set([1, 2, 3, 4, 4]);[...set];// [1, 2, 3, 4]// 例二const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);items.size; // 5// 例三const set = new Set(document.querySelectorAll(\"div\"));set.size; // 56 上面代码也展示了一种去除数组重复成员的方法。 12// 去除数组的重复成员[...new Set(array)]; 向 Set 加入值的时候，不会发生类型转换，所以 5 和”5”是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（===），主要的区别是 NaN 等于自身，而精确相等运算符认为 NaN 不等于自身。 123456let set = new Set();let a = NaN;let b = NaN;set.add(a);set.add(b);set; // Set &#123;NaN&#125; Set 结构的实例有以下属性constructor：构造函数，默认就是 Set 函数。size：返回 Set 实例的成员总数。Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面四个操作方法 123456789101112//add(value):添加某个值，返回 Set 结构本身。//delete(value):删除某个值，返回一个布尔值，表示删除是否成功。//has(value)：返回一个布尔值，表示该值是否为Set的成员。//clear()：清除所有成员，没有返回值。s.add(1).add(2).add(2);// 注意2被加入了两次s.size; // 2s.has(1); // trues.has(2); // trues.has(3); // falses.delete(2);s.has(2); // false Array.from 方法可以将 Set 结构转为数组。 12345678let set = new Set([\"red\", \"green\", \"blue\"]);for (let x of set) &#123; console.log(x);&#125;// red// green// blue Set 结构的实例与数组一样，也拥有forEach方法，用于对每个成员执行某种操作，没有返回值。 12345set = new Set([1, 4, 9]);set.forEach((value, key) =&gt; console.log(key + \" : \" + value));// 1 : 1// 4 : 4// 9 : 9 上面代码说明，forEach 方法的参数就是一个处理函数。该函数的参数与数组的 forEach 一致，依次为键值、键名、集合本身（上例省略了该参数）。这里需要注意，Set 结构的键名就是键值（两者是同一个值），因此第一个参数与第二个参数的值永远都是一样的。 扩展运算符和 Set 结构相结合，就可以去除数组的重复成员。 123let arr = [3, 5, 2, 2, 5, 5];let unique = [...new Set(arr)];// [3, 5, 2] map 结构JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。 ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。 Map 结构的实例有以下属性和操作方法。 size 属性size 属性返回 Map 结构的成员总数。 12345const map = new Map();map.set(\"foo\", true);map.set(\"bar\", false);map.size; // 2 set(key, value)set 方法设置键名 key 对应的键值为 value，然后返回整个 Map 结构。如果 key 已经有值，则键值会被更新，否则就新生成该键。 1234const m = new Map();m.set(\"edition\", 6); // 键是字符串m.set(262, \"standard\"); // 键是数值m.set(undefined, \"nah\"); // 键是 undefined set 方法返回的是当前的 Map 对象，因此可以采用链式写法。 1let map = new Map().set(1, \"a\").set(2, \"b\").set(3, \"c\"); get(key)get 方法读取 key 对应的键值，如果找不到 key，返回 undefined。 12345678const m = new Map();const hello = function () &#123; console.log(\"hello\");&#125;;m.set(hello, \"Hello ES6!\"); // 键是函数m.get(hello); // Hello ES6! has(key)has 方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。 12345678910const m = new Map();m.set(\"edition\", 6);m.set(262, \"standard\");m.set(undefined, \"nah\");m.has(\"edition\"); // truem.has(\"years\"); // falsem.has(262); // truem.has(undefined); // true delete(key)delete 方法删除某个键，返回 true。如果删除失败，返回 false。 123456const m = new Map();m.set(undefined, \"nah\");m.has(undefined); // truem.delete(undefined);m.has(undefined); // false clear()clear 方法清除所有成员，没有返回值。 123456let map = new Map();map.set(\"foo\", true);map.set(\"bar\", false);map.size; // 2map.clear();map.size; // 0 遍历 map 需要特别注意的是，Map 的遍历顺序就是插入顺序 123456789const map = new Map([ [\"F\", \"no\"], [\"T\", \"yes\"],]);for (let [key, value] of map) &#123; console.log(key, value);&#125;// \"F\" \"no\"// \"T\" \"yes\" Generators 生成器函数Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。形式上，Generator 函数是一个普通函数，但是有两个特征。一是，function 关键字与函数名之间有一个星号；二是，函数体内部使用 yield 表达式，定义不同的内部状态（yield 在英语里的意思就是“产出”） 123456function* helloWorldGenerator() &#123; yield \"hello\"; yield \"world\"; return \"ending\";&#125;var hw = helloWorldGenerator(); 上面代码定义了一个 Generator 函数 helloWorldGenerator，它内部有两个 yield 表达式（hello 和 world），即该函数有三个状态：hello，world 和 return 语句（结束执行）。 然后，Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象 yield 表达式由于 Generator 函数返回的遍历器对象，只有调用 next 方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield 表达式就是暂停标志。 遇到 yield 表达式，就暂停执行后面的操作，并将紧跟在 yield 后面的那个表达式的值，作为返回的对象的 value 属性值。 下一次调用 next 方法时，再继续往下执行，直到遇到下一个 yield 表达式。 如果没有再遇到新的 yield 表达式，就一直运行到函数结束，直到 return 语句为止，并将 return 语句后面的表达式的值，作为返回的对象的 value 属性值。 如果该函数没有 return 语句，则返回的对象的 value 属性值为 undefined 下一步，必须调用遍历器对象的 next 方法，使得指针移向下一个状态。也就是说，每次调用 next 方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个 yield 表达式（或 return 语句）为止。换言之，Generator 函数是分段执行的，yield 表达式是暂停执行的标记，而 next 方法可以恢复执行。 12345678hw.next();// &#123; value: 'hello', done: false &#125;hw.next();// &#123; value: 'world', done: false &#125;hw.next();// &#123; value: 'ending', done: true &#125;hw.next();// &#123; value: undefined, done: true &#125; 上面代码一共调用了四次 next 方法。第一次调用，Generator 函数开始执行，直到遇到第一个 yield 表达式为止。next 方法返回一个对象，它的 value 属性就是当前 yield 表达式的值 hello，done 属性的值 false，表示遍历还没有结束。第二次调用，Generator 函数从上次 yield 表达式停下的地方，一直执行到下一个 yield 表达式。next 方法返回的对象的 value 属性就是当前 yield 表达式的值 world，done 属性的值 false，表示遍历还没有结束。第三次调用，Generator 函数从上次 yield 表达式停下的地方，一直执行到 return 语句（如果没有 return 语句，就执行到函数结束）。next 方法返回的对象的 value 属性，就是紧跟在 return 语句后面的表达式的值（如果没有 return 语句，则 value 属性的值为 undefined），done 属性的值 true，表示遍历已经结束。第四次调用，此时 Generator 函数已经运行完毕，next 方法返回对象的 value 属性为 undefined，done 属性为 true。以后再调用 next 方法，返回的都是这个值。 总结一下，调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的 next 方法，就会返回一个有着 value 和 done 两个属性的对象。value 属性表示当前的内部状态的值，是 yield 表达式后面那个表达式的值；done 属性是一个布尔值，表示是否遍历结束。 class 的写法及继承JavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子 12345678910function Point(x, y) &#123; this.x = x; this.y = y;&#125;Point.prototype.toString = function () &#123; return \"(\" + this.x + \", \" + this.y + \")\";&#125;;var p = new Point(1, 2); 上面这种写法跟传统的面向对象语言（比如 C++ 和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑。ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过 class 关键字，可以定义类。 基本上，ES6 的 class 可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的 class 写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的 class 改写，就是下面这样。 1234567891011//定义类class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return \"(\" + this.x + \", \" + this.y + \")\"; &#125;&#125; 上面代码定义了一个“类”，可以看到里面有一个 constructor 方法，这就是构造方法，而 this 关键字则代表实例对象。也就是说，ES5 的构造函数 Point，对应 ES6 的 Point 类的构造方法 point 类除了构造方法，还定义了一个 toString 方法。注意，定义“类”的方法的时候，前面不需要加上 function 这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。 123//hasOwnProperty 可以用来判断对象是否有每一个属性point.hasOwnProperty(\"x\"); // truepoint.hasOwnProperty(\"y\"); // true ES6 的类，完全可以看作构造函数的另一种写法 12345class Point &#123; // ...&#125;typeof Point; // \"function\" 上面代码表明，类的数据类型就是函数，类本身就指向构造函数 类的属性名，可以采用表达式。 1234567891011let methodName = \"getArea\";class Square &#123; constructor(length) &#123; // ... &#125; [methodName]() &#123; // ... &#125;&#125; 上面代码中，Square 类的方法名 getArea，是从表达式得到的。 类内部，默认就是严格模式，所以不需要使用 use strict 指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。 考虑到未来所有的代码，其实都是运行在模块之中，所以 ES6 实际上把整个语言升级到了严格模式。 constructor 方法constructor 方法是类的默认方法，通过 new 命令生成对象实例时，自动调用该方法。一个类必须有 constructor 方法，如果没有显式定义，一个空的 constructor 方法会被默认添加。 12345class Point &#123;&#125;// 等同于class Point &#123; constructor() &#123;&#125;&#125; 上面代码中，定义了一个空的类 Point，JavaScript 引擎会自动为它添加一个空的 constructor 方法。 constructor 方法默认返回实例对象（即 this） 类必须使用 new 调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用 new 也可以执行。 123456class Foo &#123; constructor() &#123;&#125;&#125;Foo();// TypeError: Class constructor Foo cannot be invoked without 'new' 生成类的实例对象的写法，与 ES5 完全一样，也是使用 new 命令。前面说过，如果忘记加上 new，像函数那样调用 Class，将会报错。 1234567class Point &#123; // ...&#125;// 报错var point = Point(2, 3);// 正确var point = new Point(2, 3); 类不存在变量提升（hoist），这一点与 ES5 完全不同。 12new Foo(); // ReferenceErrorclass Foo &#123;&#125; 类方法加上 static 关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。 12345678910class Foo &#123; static classMethod() &#123; return \"hello\"; &#125;&#125;Foo.classMethod(); // 'hello'var foo = new Foo();foo.classMethod();// TypeError: foo.classMethod is not a function 上面代码中，Foo 类的 classMethod 方法前有 static 关键字，表明该方法是一个静态方法，可以直接在 Foo 类上调用（Foo.classMethod()），而不是在 Foo 类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。 类的继承Class 可以通过 extends 关键字实现继承 这比 ES5 的通过修改原型链（在后面章节会讲解）实现继承，要清晰和方便很多。 123class Point &#123;&#125;class ColorPoint extends Point &#123;&#125; 上面代码定义了一个 ColorPoint 类，该类通过 extends 关键字，继承了 Point 类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个 Point 类。下面，我们在 ColorPoint 内部加上代码。 12345678910class ColorPoint extends Point &#123; constructor(x, y, color) &#123; super(x, y); // 调用父类的constructor(x, y) this.color = color; &#125; toString() &#123; return this.color + \" \" + super.toString(); // 调用父类的toString() &#125;&#125; 上面代码中，constructor 方法和 toString 方法之中，都出现了 super 关键字，它在这里表示父类的构造函数，用来新建父类的 this 对象。 ES6 要求，子类的构造函数必须执行一次 super 函数 子类必须在 constructor 方法中调用 super 方法，否则新建实例时会报错。这是因为子类自己的 this 对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用 super 方法，子类就得不到 this 对象。 123456789class Point &#123; /* ... */&#125;class ColorPoint extends Point &#123; constructor() &#123;&#125;&#125;let cp = new ColorPoint(); // ReferenceError 上面代码中，ColorPoint 继承了父类 Point，但是它的构造函数没有调用 super 方法，导致新建实例时报错。 需要注意的地方是，在子类的构造函数中，只有调用 super 之后，才可以使用 this 关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有 super 方法才能返回父类实例 1234567891011121314class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125;&#125;class ColorPoint extends Point &#123; constructor(x, y, color) &#123; this.color = color; // ReferenceError super(x, y); this.color = color; // 正确 &#125;&#125; 上面代码中，子类的 constructor 方法没有调用 super 之前，就使用 this 关键字，结果报错，而放在 super 方法之后就是正确的。 本文作者：人模人样的搬砖老段本文链接：ES6如有错误，请及时评论或者知乎私信或者 B 站私信哦~ 最后更新于:2020/01/31","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"DOM高级-运动","date":"2019-04-07T15:53:02.000Z","path":"2019/04/07/DOM高级运动/","text":"运动原理运动也可以叫做动画。通过连续不断的改变物体的位置，而发生移动变化。使用 setInterval 实现。匀速运动：速度值一直保持不变。多物体同时运动：将定时器绑设置为对象的一个属性。注：物体每次运动都应该把之前的定时器清除掉。 12345//box为绝对定位var speedX = 2;box.timer = setInterval(function () &#123; box.style.left = box.offsetLeft + speedX + \"px\";&#125;, 80); 边界处理遇到边界是应该停止掉还是反弹，方向相反。改变物体运动方向：将物体的速度值取反。 1234567//边界属性 浏览器视口宽高//返回当前视口的高度（即浏览器窗口的高度）console.log(document.documentElement.clientHeight);console.log(document.documentElement.clientWidth);// 网页总高度 body默认有margin，记得重置console.log(document.body.clientHeight);console.log(document.body.clientWidth); 12345678var speedX = 2 box.timer = setInterval(function()&#123; box.style.left = box.offsetLeft + speedX +'px'; //左右边界 if(box.offsetLeft &lt;=0 || box.offsetLeft &gt;= cWidth - box.offsetWidth)&#123; speedX = -speedX; &#125;&#125;,80 加速减速加速：速度越来越快。减速：速度越来越慢。 1234box.timer = setInterval(function () &#123; speedX = speedX + 2; div.style.left = div.offsetLeft + speedX + \"px\";&#125;, 50); 抛物线水平方向有一速度，垂直方向有一速度，并做自由落体。 123456789var speedY = 0;var speedX = 10;// x 方向 匀速// y 方向 匀加速box.timer = setInterval(function () &#123; speedY += 9.8; box.style.left = box.offsetLeft + speedX + \"px\"; box.style.top = box.offsetTop + speedY + \"px\";&#125;, 80); 透明度的变换box 逐渐消失 12345678//使用css将box的opacity 设置为1var op = 1;box.timer = setInterval(function () &#123; op = op - 0.01; div.style.opacity = op; //或者 //div.style.opacity = getComputedStyle(div).opacity - 0.01;&#125;, 80); 缓冲运动速度一开始很大，然后慢慢变小，比较类似自然界中的缓冲运动 12345678910111213//一开始box 在 （0，0）位置，我们将box运动到（300,0）位置var target = 300; //目标位置box.timer = setInterval(function () &#123; //target - div.offsetLeft 是元素距离目标的路程，随着越来越靠近目标，这个值就越来越小，如果把这个值当做速度，速度一开始很大，然后慢慢变小，比较类似自然界中的缓冲运动。如果把这个值直接当速度，一下子就到，所以除以8以后当做速度 var speed = (target - div.offsetLeft) / 8; //所以要对速度向上取整得到速度1，当speed小于0.375的时候，div就不会移动了 speed = Math.ceil(speed); box.style.left = div.offsetLeft + speed + \"px\"; if (box.offsetLeft == target) &#123; //到达目标清除定时器 clearInterval(box.timer); &#125;&#125;, 30); 考虑到运动的时候可能往前，也可以能往后，增加判断 1234567891011121314151617181920//一开始box 在 （0，0）位置，我们将box运动到（300,0）位置var target = 300; //目标位置div.timer = setInterval(function () &#123; var speed = (target - div.offsetLeft) / 8; //当speed小于0.375的时候，div就不会移动了 //所以要对速度向上取整或者向下取整 if (speed &gt; 0) &#123; //speed大于0 说明是往前运动 //当speed小于0.375的时候，div就不会移动了 //所以要对速度向上取整或者向下取整 speed = Math.ceil(speed); &#125; else &#123; //speed大于0 说明是往后运动 speed = Math.floor(speed); &#125; div.style.left = div.offsetLeft + speed + \"px\"; if (div.offsetLeft == target) &#123; clearInterval(div.timer); &#125;&#125;, 30); 上面代码封装为函数 1234567891011function animate(div, targetX) &#123; var target = targetX; div.timer = setInterval(function () &#123; var speed = (target - div.offsetTop) / 8; speed = speed &gt; 0 ? Math.ceil(speed) : Math.floor(speed); div.style.top = div.offsetTop + speed + \"px\"; if (div.offsetTop == target) &#123; clearInterval(div.timer); &#125; &#125;, 30);&#125; 多属性缓冲运动函数封装上面的封装只能固定的在 x 方向做动画如果想让一个 div 从一个点运动到另一个点，怎么办？比如从（0，0）到（100，200）这个时候我们把第二个参数改为一个这样的对象 {left:100;top:200} 123456789101112131415161718192021222324function animate(div, obj) &#123; //&#123;left:100;top:200&#125; //&#123;left:100&#125; clearInterval(div.timer); div.timer = setInterval(function () &#123; var flag = true; //假设已经到了目的地 for (var key in obj) &#123; console.log(key); //left top console.log(obj[key]); //300 var target = obj[key]; //目标值 // getComputedStyle['left'] 元素left 属性 当前值 var speed = (target - parseInt(getComputedStyle(div)[key])) / 8; speed = speed &gt; 0 ? Math.ceil(speed) : Math.floor(speed); div.style[key] = parseInt(getComputedStyle(div)[key]) + speed + \"px\"; if (parseInt(getComputedStyle(div)[key]) != target) &#123; flag = false; &#125; &#125; //必须等到所有的 属性都到达目的地 才能结束定时器 if (flag == true) &#123; clearInterval(div.timer); &#125; &#125;, 30);&#125; 本文作者：人模人样的搬砖老段本文链接：DOM 高级-运动如有错误，请及时评论或者知乎私信或者 B 站私信哦~ 最后更新于:2020/01/28","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"DOM高级","slug":"DOM高级","permalink":"http://yoursite.com/tags/DOM%E9%AB%98%E7%BA%A7/"}]},{"title":"localStorage本地存储","date":"2019-03-23T16:12:55.000Z","path":"2019/03/24/localStorage本地存储/","text":"什么是 localStorage在 HTML5 中，新加入了一个 localStorage 特性，这个特性主要是用来作为本地存储来使用的，解决了 cookie 存储空间不足的问题(cookie 中每条 cookie 的存储空间为 4k)，localStorage 中一般浏览器支持的是 5M 大小，这个在不同的浏览器中 localStorage 会有所不同 localStorage 的优势 localStorage 拓展了 cookie 的 4K 限制 localStorage 会可以将第一次请求的数据直接存储到本地，这个相当于一个 5M 大小的针对于前端页面的数据库，相比于 cookie 可以节约带宽，但是这个却是只有在高版本的浏览器中才支持的 localStorage 的局限 浏览器的大小不统一，并且在 IE8 以上的 IE 版本才支持 localStorage 这个属性 目前所有的浏览器中都会把 localStorage 的值类型限定为 string 类型，这个在对我们日常比较常见的 JSON 对象类型需要一些转换 localStorage 的写入localStorage 的写入有三种方法。 localStorage 只支持 string 类型的存储 1234567var storage = window.localStorage;//写入a字段storage[\"a\"] = 1;//写入b字段storage.a = 1;//写入c字段storage.setItem(\"c\", 3); 三种对 localStorage 的读取其中官方推荐的是 getItem\\setItem 这两种方法对其进行存取 123456789//第一种方法读取var a = storage.a;console.log(a);//第二种方法读取var b = storage[\"b\"];console.log(b);//第三种方法读取var c = storage.getItem(\"c\");console.log(c); localStorage 的修改改这个步骤比较好理解，思路跟重新更改全局变量的值一样 12345var storage = window.localStorage;//写入a字段storage[\"a\"] = 1;storage.a = 4; //修改console.log(storage.a); localStorage 的删除将 localStorage 中的某个键值对删除 123storage.setItem(\"c\", 3);console.log(storage);storage.removeItem(\"a\"); 将 localStorage 的所有内容清除 1storage.clear(); localStorage 其他注意事项一般我们会将 JSON(js 中的对象)存入 localStorage 中，但是在 localStorage 会自动将 localStorage 转换成为字符串形式这个时候我们可以使用 JSON.stringify()这个方法，来将 JSON 转换成为 JSON 字符串 123456789var data = &#123; name: \"zhangsan\", sex: \"man\",&#125;;var d = JSON.stringify(data);storage.setItem(\"data\", d);//将JSON字符串转换成为JSON对象输出var json = storage.getItem(\"data\");var jsonObj = JSON.parse(json); 本文作者：人模人样的搬砖老段本文链接：localStorage 本地存储如有错误，请及时评论或者知乎私信或者 B 站私信哦~ 最后更新于:2020/01/28","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"localStorage","slug":"localStorage","permalink":"http://yoursite.com/tags/localStorage/"}]},{"title":"3D转换和关键帧动画","date":"2019-03-10T07:28:42.000Z","path":"2019/03/10/3D转换和关键帧动画/","text":"CSS3 3D 转换CSS3 3D 转换 transform(3D 位移、缩放、旋转) 让元素方式 3d 的变换，同 2d 变换一样，通过 transform 来设置位移：translate3D(x,y,z)缩放：scale3d(x,y,z) scalez()不能单独使用；旋转：rotatex(80deg) rotatey(80deg) rotatez(80deg) 转换是使元素改变形状、尺寸和位置的一种效果。 可以使用 2D 或 3D 转换来转换元素。 在转换概念当中：是没有 display 这么一说的，通过改变元素的透明度去实现从无到有 IE 10 和 Firefox 支持 3D 转换。 Chrome 和 Safari 需要前缀 -webkit-。 Opera 仍然不支持 3D 转换（它只支持 2D 转换）。 观察的场所—-3D 空间 transform-styletransform-style:preserve-3d; 表示所有子元素在 3D 空间呈现 近大远小—-景深 perspective元素距离观察点的距离（物体和眼睛的距离越小，近大远小的效果越明显）perspective:1200px;(在父元素中使用）通常的数值在 900-1200 之间，如果当你的视线距离物体足够远的时候，基本上就不会有近大远小的感觉 观察 3D 元素的（位置）角度—-景深的角度perspective-originperspective-origin:left top （左上角） 这三种写法是等价 12345transform: translate3d(30px,30px,800px )transform:translateZ(800px) translateX(30px) translateY(30px) ;transform:translateZ(800px) translate(30px,30px); preserve-3d放到父元素 12345-webkit-transform-style: preserve-3d;-moz-transform-style: preserve-3d;-ms-transform-style: preserve-3d;-o-transform-style: preserve-3d;transform-style: preserve-3d; transform 向元素应用 2D 或 3D 转换。transform-origin 允许你改变被转换元素的位置。transform-style 规定被嵌套元素如何在 3D 空间中显示。perspective 规定 3D 元素的透视效果。perspective-origin 规定 3D 元素的底部位置。backface-visibility 定义元素在不面对屏幕时是否可见。 2D Transform 方法matrix3d(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n) 定义 3D 转换，使用 16 个值的 4x4 矩阵。translate3d(x,y,z) 定义 3D 转化。translateX(x) 定义 3D 转化，仅使用用于 X 轴的值。translateY(y) 定义 3D 转化，仅使用用于 Y 轴的值。translateZ(z) 定义 3D 转化，仅使用用于 Z 轴的值。scale3d(x,y,z) 定义 3D 缩放转换。scaleX(x) 定义 3D 缩放转换，通过给定一个 X 轴的值。scaleY(y) 定义 3D 缩放转换，通过给定一个 Y 轴的值。scaleZ(z) 定义 3D 缩放转换，通过给定一个 Z 轴的值。rotate3d(x,y,z,angle) 定义 3D 旋转。rotateX(angle) 定义沿 X 轴的 3D 旋转。rotateY(angle) 定义沿 Y 轴的 3D 旋转。rotateZ(angle) 定义沿 Z 轴的 3D 旋转。perspective(n) 定义 3D 转换元素的透视视图。 CSS3 动画通过 CSS3，我们能够创建动画，这可以在许多网页中取代动画图片、Flash 动画以及 JavaScript CSS3 @keyframes 规则如需在 CSS3 中创建动画，需要学习 @keyframes 规则。@keyframes 规则用于创建动画。在 @keyframes 中规定某项 CSS 样式，就能创建由当前样式逐渐改为新样式的动画效果。Internet Explorer 10、Firefox 以及 Opera 支持 @keyframes 规则和 animation 属性。Chrome 和 Safari 需要前缀 -webkit-。 注释：Internet Explorer 9，以及更早的版本，不支持 @keyframe 规则或 animation 属性。 使用方法 第一步： 123456@-webkit-keyframes 动画名称&#123; 0%｛ 本关键帧中的样式｝ 10%｛ 本关键帧中的样式｝ 。。。。。。 100%｛ 本关键帧中的样式｝ &#125; 第二步：动画设计好后，使用 animation 属性调用动画。方法如下： 12想加动画元素的选择器&#123; -webkit-animation: move 2s 3s linear 2 normal ｝ /* 动画名称 持续时间 延迟时间 运动形式 播放次数 是否倒放*/ 关键帧语法 12345678@keyframes name &#123; from &#123; properties: Properties value; &#125; to &#123; properties: Properties value; &#125;&#125; 样例 123456789101112131415161718@-webkit-keyframes move &#123; 0% &#123; margin-left: 100px; background: green; &#125; 40% &#123; margin-left: 150px; background: orange; &#125; 60% &#123; margin-left: 75px; background: blue; &#125; 100% &#123; margin-left: 100px; background: red; &#125;&#125; 12345678-webkit-animation-name: move; /*动画属性名，前面keyframes样例定义的动画名*/-webkit-animation-duration: 10s; /*动画持续时间*/-webkit-animation-timing-function: ease-in-out; /*动画帧频，和transition-timing-function是一样的*//*ease | linear | ease-in | ease-out | cubic-Bezier (n1 , n2, n3, n4)*/-webkit-animation-delay: 2s; /*动画延迟时间*/-webkit-animation-iteration-count: 10; /*动画循环次数，infinite为无限次*/-webkit-animation-direction: normal; /*定义动画播放方式*//*默认normal，动画正常播放； alternate，动画轮流反向播放*/ 实现动画的方法：A、linear：从开始到结束都是以同样的速度进行.B、ease-in：开始速度很慢，然后沿着曲线进行加快.C、ease-out：开始速度很快，然后沿着曲线进行减速.D、ease：开始时速度很快，然后沿着曲线进行减速，然后再沿着曲线加速.E、ease-in-out：开始时速度很慢，然后沿着曲线进行加速，然后再沿着曲线减速.F、step-start; /_ 马上跳到动画每一结束桢的状态 _/ CSS3 动画属性 @keyframes 规定动画。animation 所有动画属性的简写属性，除了 animation-play-state 属性。animation-name 规定 @keyframes 动画的名称。animation-duration 规定动画完成一个周期所花费的秒或毫秒。默认是 0。animation-timing-function 规定动画的速度曲线。默认是 “ease”。animation-delay 规定动画何时开始。默认是 0。animation-iteration-count 规定动画被播放的次数。默认是 1。animation-direction 规定动画是否在下一周期逆向地播放。默认是 “normal”。animation-play-state 规定动画是否正在运行或暂停。默认是 “running”。animation-fill-mode 规定对象动画时间之外的状态。 本文作者：人模人样的搬砖老段本文链接：3D 转换和关键帧动画如有错误，请及时评论或者知乎私信或者 B 站私信哦~ 最后更新于:2020/01/28","tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"3D转换","slug":"3D转换","permalink":"http://yoursite.com/tags/3D%E8%BD%AC%E6%8D%A2/"},{"name":"关键帧动画","slug":"关键帧动画","permalink":"http://yoursite.com/tags/%E5%85%B3%E9%94%AE%E5%B8%A7%E5%8A%A8%E7%94%BB/"}]},{"title":"CSS核心属性(二)","date":"2019-02-24T03:57:55.000Z","path":"2019/02/24/CSS核心属性-二/","text":"CSS3 渐变线性渐变（Linear Gradient）- 向下/向上/向左/向右/对角方向径向渐变（Radial Gradient）- 由它们的中心定义repeating-linear-gradient() 函数用于重复线性渐变 线性渐变 （默认从上向下） background: linear-gradient(red, blue); 基本的渐变，默认从上向下 background: linear-gradient(to right, red , blue); 从左向右的渐变 background: linear-gradient(to bottom right, red , blue);从左上角到右下角/ background: linear-gradient(180deg, red, blue);带有指定角度的渐变 background: linear-gradient(to right, rgba(255,0,0,0), rgba(255,0,0,1));使用透明色渐变 transparent 透明色 百分比渐变: 渐变过渡区的占比为总的空间（高度或宽度）减去上下两个着色块空间占比剩下的空间。background:linear-gradient(red,orange) 如果前面有比当前的颜色值百分比大的，会自动将当前颜色值的百分比设置为前面颜色中的最大百分比值例：background:linear-gradient(red 0%, red 14.3%, orange 0, orange 28.6%, yellow 0, yellow 42.9%, green 0, green 57.2%, blue 0, blue 71.5%, indigo 0, indigo 85.8%, violet 0, violet 100% );background:linear-gradient( red 0%, orange 16.67%, yellow 33.33%, green 50%, blue 66.67%, indigo 83.33%, violet 100% ); 重复的线性渐变background: repeating-linear-gradient(red,yellow 10%, green 20%); 径向渐变 background: radial-gradient(red, green, blue);颜色结点均匀分布的径向渐变： background: radial-gradient(red 5%, green 15%, blue 60%); 颜色节点分布不均匀 background: repeating-radial-gradient(red, yellow 10%, green 15%); 重复的径向渐变 设置形状shape 参数定义了形状。它可以是值 circle 或 ellipse。其中，circle 表示圆形，ellipse 表示椭圆形。默认值是 ellipse。 形状为圆形的径向渐变：background: radial-gradient(circle, red, yellow, green); 深入理解径向渐变 CSS3 变形(2D 转换)css3 中 transform 可以实现文字或图像的旋转（rotate）、缩放(scale)、倾斜(skew)、移动(translate)的变形效果。 旋转、缩放、倾斜和移动，这四种变形效果进行结合使用，并且使用的先后顺序不同，页面显示的结果会有区别。 使用语法： 12345transform:功能;-ms-transform:功能; &#x2F;* IE 9 *&#x2F;-moz-transform:功能; &#x2F;* Firefox *&#x2F;-webkit-transform:功能; &#x2F;* Safari 和 Chrome *&#x2F;-o-transform:功能; &#x2F;* Opera *&#x2F; 移动translateX(n) translateY(n) 沿着 X 或 Y 轴移动元素。translate(x,y) 沿着 X 和 Y 轴移动元素。实例： 123456/*值 translate(50px,100px) 把元素从左侧移动 50 像素，从顶端移动 100 像素。*/div&#123;transform: translate(50px,100px);-ms-transform: translate(50px,100px); /* IE 9 */-webkit-transform: translate(50px,100px); /* Safari and Chrome */-o-transform: translate(50px,100px); /* Opera */-moz-transform: translate(50px,100px); /* Firefox */&#125; 缩放scaleX(n) scaleY(n) 改变元素的宽或高度。scale(x,y) 改变元素的宽度和高度。实例： 123456/*值 scale(2,4) 把宽度转换为原始尺寸的 2 倍，把高度转换为原始高度的 4 倍。*/div&#123;transform: scale(2,4);-ms-transform: scale(2,4); /* IE 9 */-webkit-transform: scale(2,4); /* Safari 和 Chrome */-o-transform: scale(2,4); /* Opera */-moz-transform: scale(2,4); /* Firefox */&#125; 定义 2D 旋转rotate(angle)在参数中规定角度。turn 是圈，1turn = 360deg；另外还有弧度 rad，2πrad = 1turn = 360deg。如，transform:rotate(2turn); 旋转两圈实例： 123456/*值 rotate(30deg) 把元素顺时针旋转 30 度。*/div&#123;transform: rotate(30deg);-ms-transform: rotate(30deg); /* IE 9 */-webkit-transform: rotate(30deg); /* Safari and Chrome */-o-transform: rotate(30deg); /* Opera */-moz-transform: rotate(30deg); /* Firefox */&#125; 关于旋转 rotate；改变旋转中心点：transform-origin: left top 倾斜skewX(angle) skewY(angle) 沿着 X 或 Y 轴倾斜。skew(x-angle,y-angle) 沿着 X 和 Y 轴倾斜。实例： 123456/*值 skew(30deg,20deg) 围绕 X 轴把元素翻转 30 度，围绕 Y 轴翻转 20 度。*/div&#123;transform: skew(30deg,20deg);-ms-transform: skew(30deg,20deg); /* IE 9 */-webkit-transform: skew(30deg,20deg); /* Safari and Chrome */-o-transform: skew(30deg,20deg); /* Opera */-moz-transform: skew(30deg,20deg); /* Firefox */&#125; CSS3 过渡transition 属性的使用方法： 1234transition:语法;-moz-transition: 语法; &#x2F;* Firefox 4 *&#x2F;-webkit-transition:语法; &#x2F;* Safari 和 Chrome *&#x2F;-o-transition:语法; &#x2F;* Opera *&#x2F; css3 中 transition 允许 css 的属性值在一定的时间区间内平滑地过渡。这种效果可以在鼠标单击、获得焦点、被点击或对元素任何改变中触发，并圆滑地以动画效果改变 CSS 的属性值。 语法：transition: property duration timing-function delay ; 执行变换的属性：transition-property，属性规定应用过渡效果的 CSS 属性的名称。（当指定的 CSS 属性改变时，过渡效果将开始） 值有三个类型： A、none 没有属性会获得过渡效果。 B、all 所有属性都将获得过渡效果。 C、property 定义应用过渡效果的 CSS 属性名称列表，列表以逗号分隔。 变换延续的时间：transition-duration； 规定完成过渡效果需要花费的时间（以秒或毫秒计），默认值 0 没有效果 在延续时间段，变换的速率变化 transition-timing-function； 值： A、ease：（逐渐变慢）默认值，ease 函数等同于贝塞尔曲线(0.25, 0.1, 0.25, 1.0). B、linear：（匀速），linear 函数等同于贝塞尔曲线(0.0, 0.0, 1.0, 1.0). C、ease-in：(加速)，ease-in 函数等同于贝塞尔曲线(0.42, 0, 1.0, 1.0). D、ease-out：（减速），ease-out 函数等同于贝塞尔曲线(0, 0, 0.58, 1.0). E、ease-in-out：（加速然后减速），ease-in-out 函数等同于贝塞尔曲线(0.42, 0, 0.58, 1.0) F、cubic-bezier(n,n,n,n) 在 cubic-bezier 函数中定义自己的值。可能的值是 0 至 1 之间的数值。 CSS3 滤镜Css3 里的滤镜：将图片转换成灰度图片-webkit-filter: grayscale(100%); 本文作者：人模人样的搬砖老段本文链接：CSS 核心属性(二)如有错误，请及时评论或者知乎私信或者 B 站私信哦~ 最后更新于:2019/12/21","tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/tags/CSS3/"},{"name":"2D转换","slug":"2D转换","permalink":"http://yoursite.com/tags/2D%E8%BD%AC%E6%8D%A2/"}]},{"title":"移动端布局","date":"2019-02-10T01:28:58.000Z","path":"2019/02/10/移动端布局/","text":"响应式网站设计什么是响应式布局 服务器根据不同的浏览器用户端，为用户呈现不同的页面效果。 可以让一个网站兼容不同分辨率的设备，给用户更好的视觉使用体验。 移动互联网催生了响应式布局的诞生。 响应式设计优缺点优点:解决了设备之间的差异化展示,让不同的设备达到最优的视觉体验.缺点:兼容性代码多,工作量大,加载速度受影响对原有网站布局会产生影响,用户判断未必精确. 响应式设计的原则 移动优先：在设计的初期就考虑页面如何在多终端展示 渐进增强：充分发挥硬件设备的最大功能 如何实现响应式布局 css3-Media Query：代码简单（媒体查询） 借助原生 Javascript：主要用于老浏览器上，加载速度慢，不推荐 第三方的开源框架，如 bootstrap，可以很好的实现浏览器对响应式的支持 基本语法外联 CSS 语法 12345678910&lt;link rel=\"“stylesheet”\" href=\"“wide.css”\" media=\"screen and (min-width:320px)\"/&gt;&lt;link rel=\"“stylesheet”\" href=\"“mobile.css”\" media=\"screen and (max-width:1000px)\"/&gt; 内嵌样式的语法 123&lt;style&gt; @media all and (min-width:500px) &#123; … &#125;&lt;/style&gt; CSS 2.1 支持 9 种媒体类型——注意：媒体类型名区分大小写braille ——触觉反馈设备embossed ——盲文印刷设备handheld ——小型或手持设备print ——打印机projection ——投影图像，如幻灯screen ——计算机显示器speech ——语音合成器tty ——打字机tv ——电视类all 所有 响应式不同分辨率设置 1024px 显屏 1@media screen and (max-width : 1024px) &#123; /* 样式写在这里 */ &#125; 800px 显屏 1@media screen and (max-width : 800px) &#123; /* 样式写在这里 */ &#125; 640px 显屏 1@media screen and (max-width : 640px) &#123; /* 样式写在这*/ &#125; iPad 横板显屏 12@media screen and (max-device-width: 1024px) and (orientation: landscape) &#123;/*样式写在这 */ &#125; iPad 竖板显屏 12@media screen and (max-device-width: 768px) and (orientation: portrait) &#123;/*样式写在这 */ &#125; 移动端和 PC 端页面布局的不同点 显示设备（屏幕） 操作（鼠标、指尖） 浏览器内核:移动端不用考虑 ie，但是各种浏览器内核（手机自带）、微信浏览器内核 运行设备 移动设备（轻便、迅速、便携） pc 端（体验） 网络不同 移动 4g（注重速度） pc 光纤（注重体验速度） 做移动端页面和 pc 端页面使用的方法也不同页面设置不同：1.Meta 标签设置 2.单位=======用来适应不同的移动端屏幕尺寸； Px 像素。类似绝对单位。其实也是相对单位，相对于屏幕的分辨率；Pt 磅 点 打印的尺寸Em 相对单位，相对于父级的 font-size 1em=父级的 font-size（直接的父级）Rem 相对单位，相对于根元素的 font-size 1rem=根元素的 font-sizeVw，相对于屏幕的宽度 ，1vw==1%屏幕的宽度Vh 相对单位，相对于屏幕高度，1vh==1%屏幕的高度 Meta 标签的设置不同1234&lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no\"/&gt; width=device-width:宽度等于当前设备的宽度intial-scale:页面首次被显示是可视区域的缩放比例，取值 1.0 则页面按实际尺寸显示，无任何缩放maximum-scale=1.0, minimum-scale=1.0;可视区域的缩放级别，maximum-scale用户可将页面放大的程序，1.0 将禁止用户放大到实际尺寸之上。user-scalable:是否可对页面进行缩放，no 禁止缩放 Meta 标签的设置不同及其不同的效果（扩展）1.强制让文档与设备的宽度保持 1：1 1234&lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no\"/&gt; 2.忽略页面中的数字识别为电话号码 12&lt;meta name=\"format-detection\" content=\"telephone=no\" /&gt;3.忽略页面中的邮箱格式为邮箱 &lt;meta name=\"format-detection\" content=\"email=no\" /&gt; 4.在 web app 应用下状态条（屏幕顶部条）的颜色 1&lt;meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\" /&gt; 认识 ppi 、dpr 、dpi屏幕尺寸：指的是屏幕对角线的长度分辨率：是指宽度上和高度上最多能显示的物理像素点个数点距：像素与像素之间的距离，点距和屏幕尺寸决定了分辨率大小PPI:屏幕像素密度，即每英寸(1 英寸=2.54 厘米)聚集的像素点个数，这里的一英寸还是对角线长度DPI:每英寸像素点，印刷行业术语。对于电脑屏幕而言和 PPI 是一个意思设备像素(又称为物理像素): 指设备能控制显示的最小物理单位，意指显示器上一个个的点。从屏幕在工厂生产出的那天起，它上面设备像素点就固定不变了，和屏幕尺寸大小有关，单位 pt。设备独立像素(也叫密度无关像素或逻辑像素)：可以认为是计算机坐标系统中的一个点，这个点代表一个可以由程序使用的虚拟像素(比如: css 像素)，这个点是没有固定大小的，越小越清晰，然后由相关系统转换为物理像素。css 像素(也叫虚拟像素)：指的是 CSS 样式代码中使用的逻辑像素，在 CSS 规范中，长度单位可以分为两类，绝对(absolute)单位以及相对(relative)单位。px 是一个相对单位，相对的是设备像素(device pixel)DPR(设备像素比)：设备像素比 = 设备像素 / css 像素。(在 Retina 屏的 iphone 上，DPR 为 2，1 个 css 像素相当于 2 个物理像素)每英寸像素(pixel per inch, ppi/PPI): 它表示的是每英寸所拥有的像素(pixel)数目，更确切的说法应该是像素密度，放到显示器上说的是每英寸多少物理像素及显示器设备的点距。数值越高，代表显示屏能够以越高的密度显示图像。设备像素比(device pixel ratio, dpr/DPR): 它描述的是未缩放状态下，设备像素和 CSS 像素的初始比例关系，也可以解释为默认缩放比例。如何理解这个概念呢？通俗来说，它是指在开发中 1 个 CSS 像素占用多少设备像素，如 dpr=2 代表 1 个 CSS 像素用 2x2 个设备像素来绘制，这是因为 Retina 屏幕把 2x2 个像素当 1 个像素使用。比如原本 44 像素高的顶部导航栏，在 Retina 屏上用了 88 个像素的高度来显示。导致界面元素都变成 2 倍大小 vw 和 rem 做适配 只用 vw 单位做适配如果设计稿的尺寸为 750px；那么 100vw=750px; 1vw=7.5px vw 结合 rem 做适配假如 ui 图的宽度为 1920px，又因为 vw 会把宽度分为 100 份，那 1vw=19.2px，1920/100=19.2（px），现在这样还是不行，不好算，那就算出每 100px 是多少 vw，100px=(约等于)5.21（vw），这样，设根字体 html 为 5.21vw，则 0.18rem=18px（1rem=100px） 1vw=19.2px 1px= 0.05208 vw 100px=5.21vwhtml{font-size:5.21vw} 5.21vw=100px=1rem Js 方法获取 HTMLfontsize（需要手动刷新）12345&lt;script&gt; var bw = document.documentElement.clientWidth / 7.2 + \"px\"; //获取屏幕宽度)除以7.2，添加上“px”，7.2是设计稿的宽度除以100后得到的值 var htmlTag = document.getElementsByTagName(\"html\")[0]; //在文档里面通过元素名来获取元素，html htmlTag.style.fontSize = bw; //把计算后的值复制给根元素的font-size;1rem=100px&lt;/script&gt; 12345678910111213141516&lt;script&gt; window.onload = function () &#123; /*720代表设计师给的设计稿的宽度，你的设计稿是多少，就写多少;100代表换算比例，这里写100是 为了以后好算,比如，你测量的一个宽度是100px,就可以写为1rem,以及1px=0.01rem等等*/ getRem(640, 100); &#125;; window.onresize = function () &#123; getRem(640, 100); &#125;; function getRem(pwidth, prem) &#123; var html = document.getElementsByTagName(\"html\")[0]; var oWidth = document.body.clientWidth || document.documentElement.clientWidth; html.style.fontSize = (oWidth / pwidth) * prem + \"px\"; &#125;&lt;/script&gt; 移动端适配方案总结移动端的适配方案 Vw 单位做适配1、设计稿尺寸=100vw 算出 1vw=？Px2、量出来的尺寸换算成 vw 单位书写 css 中； Vw 结合 rem 适配1、设计稿的尺寸=100vw。算出 1vw=？Px；2、算出 100px=？？vw；3、html{font-size:？？vw}这时 1rem=100px4、量出的尺寸除以 100，就是得出的 rem 单位的值 Js 适配1、引用 js；注意修改 js 中的一个参数，参数值设置成设计稿的尺寸2、直接 1rem=100px;量出的尺寸除以 100，就是得出的 rem 单位的值 本文作者：人模人样的搬砖老段本文链接：移动端布局如有错误，请及时评论或者知乎私信或者 B 站私信哦~ 最后更新于:2020/01/27","tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"响应式布局","slug":"响应式布局","permalink":"http://yoursite.com/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80/"}]},{"title":"弹性盒模型和几种布局方式","date":"2019-01-27T12:07:45.000Z","path":"2019/01/27/弹性盒模型和几种布局方式/","text":"怪异盒模型浏览器对盒模型的解析一共有两种模式，一种是标准模式，另一种就是怪异模式。一般在页面头部声明了 DOCTYPE，都会触发标准模式，而如果 DOCTYPE 缺失则在 ie6，ie7，ie8 下将会触发怪异模式（quirks 模式）。标准盒模型和怪异盒模型的区别：在标准模式下，一个块的总宽度= width + margin(左右) + padding(左右) + border(左右)在怪异模式下，一个块的总宽度= width + margin(左右)（即 width 已经包含了 padding 和 border 值） Css3 中 box-sizing：属性让两种盒模型相互转变box-sizing ： content-box || border-box || inherit;当设置为 box-sizing:content-box 时，将采用标准模式解析计算，也是默认模式；当设置为 box-sizing:border-box 时，将采用怪异模式解析计算； 新版盒模型Flex 布局是什么？传统 的布局方案，是基于盒模型，依赖 display+position+float，但是对于特殊的布局就非常的不方便，如：垂直居中，2009 年为 w3c 提出一种新方案—–flex 布局，目前兼容的浏览器有：Chrome 21+Opera 12.1+FireFox 22+Safari 6.1+IE 10+ 在未来 flex 布局将成为布局的首选方案Flex 是 flexinle Box 的缩写，意思是弹性布局；用来为盒模型提供最大的灵活性，任何一个容器都可以指定为 flex 布局。即：display：flex； 注：设置了 flex 布局后当前容器内子元素的 float、clear、vertical-align 属性将全部消失 Flex 基本概念采用 flex 布局的元素，称为 flex 容器，它的所有子元素自动成为容器成员，称为容器项目 容器默认存在两根轴：水平的主轴（main axis）和垂直交叉轴（cross axis）.主轴的开始位置（与边框的交叉点）叫做 main start, 结束位置叫做 main end ;交叉轴的开始位置叫做 cross start ,结束位置叫做 cross end.项目默认沿主轴排列。单个项目占据的主轴空间叫做 main size,占据的交叉轴叫做 cross size. 容器的属性 display：flex设置为弹性盒(父元素添加) flex-direction (主轴的方向)说明：指定了弹性子元素在父容器中的位置row 默认在一行内排列row-reverse：反转横向排列（右对齐，从后往前排，最后一项排在最前面。）column：纵向排列。column-reverse：反转纵向排列，从下往上排，最后一项排在最上面 justify-content(主轴对齐方式)内容对齐（justify-content）属性应用在弹性容器上，把弹性项沿着弹性容器的主轴线（main axis）对齐flex-start 默认，左对齐flex-end 右对齐center 居中对齐space-between 两端对齐，中间自动分配space-around 自动分配距离 align-items（侧轴对齐方式）flex-start：顶端对齐flex-end：底对齐center：垂直居中对齐baseline：项目内文本的底线对齐stretch 默认值 项目的高度自适应容器（注：子元素不能设置高度） flex-wrap该属性控制 flex 容器是单行或者多行，同时横轴的方向决定了新行堆叠的方向。nowrap：flex 容器为单行。该情况下 flex 子项可能会溢出容器wrap：flex 容器为多行。该情况下 flex 子项溢出的部分会被放置到新行，子项内部会发生断行wrap-reverse：反转 wrap 排列。 align-content（行与行之间对齐方式）当伸缩容器的侧轴还有多余空间时，本属性可以用来调整「伸缩行」在伸缩容器里的对齐方式，这与调整伸缩项目在主轴上对齐方式的 &lt;’justify-content’&gt; 属性类似。注：本属性在只有一行的伸缩容器上没有效果。flex-start没有行间距flex-end底对齐没有行间距center居中没有行间距space-between两端对齐，中间自动分配space-around自动分配距离 align-selfalign-self 属性规定灵活容器内被选中项目的对齐方式。注意：align-self 属性可重写灵活容器的 align-items 属性。auto 默认值。元素继承了它的父容器的 align-items 属性。如果没有父容器则为 “stretch”。stretch元素被拉伸以适应容器。center元素位于容器的中心。flex-start元素位于容器的开头。flex-end 元素位于容器的结尾。Internet Explorer 和 Safari 浏览器不支持 align-self 属性。 ordernumber 排序优先级，数字越大越往后排，默认为 0，支持负数。 flex-growflex-grow 属性定义项目的放大比例，默认为 0，即如果存在剩余空间，也不放大。 123.item &#123; flex-grow: &lt;number&gt;;&#125; 如果所有项目的 flex-grow 属性都为 1，则它们将等分剩余空间（如果有的话）。如果一个项目的 flex-grow 属性为 2，其他项目都为 1，则前者占据的剩余空间将比其他项多一倍。 flex-shrinkflex-shrink 属性定义了项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小。如果所有项目的 flex-shrink 属性都为 1，当空间不足时，都将等比例缩小。如果一个项目的 flex-shrink 属性为 0，其他项目都为 1，则空间不足时，前者不缩小。负值对该属性无效。 flex-basisflex-basis 属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为 auto，即项目的本来大小。它可以设为跟 width 或 height 属性一样的值（比如 350px），则项目将占据固定空间。 flex复合属性。设置或检索弹性盒模型对象的子元素如何分配空间flex 属性是 flex-grow, flex-shrink 和 flex-basis 的简写，默认值为 0 1 auto。后两个属性可选。该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 CSS3 多列分栏布局1.column-count：auto | 整数；—控制栏数2.column-width：value；—每栏的宽度3.column-gap : value ;—两栏之间的间距4.column-rule : 宽度，线型，颜色；—栏与栏的间隔线类似 border，solid | dotted | dashed 实线 | 点线 | 虚线 column-width 和 column-count 这两个属性提供了分栏的标准，只写其中的一个column-gap 和 column-rule 就处在相邻两列之间 让某个元素跨栏加到某个元素上：column-span : all / none ; 是否跨栏显示 本文作者：人模人样的搬砖老段本文链接：弹性盒模型和几种布局方式如有错误，请及时评论或者知乎私信或者 B 站私信哦~ 最后更新于:2020/01/22","tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"弹性盒模型","slug":"弹性盒模型","permalink":"http://yoursite.com/tags/%E5%BC%B9%E6%80%A7%E7%9B%92%E6%A8%A1%E5%9E%8B/"},{"name":"多栏布局","slug":"多栏布局","permalink":"http://yoursite.com/tags/%E5%A4%9A%E6%A0%8F%E5%B8%83%E5%B1%80/"}]},{"title":"CSS3新特性","date":"2019-01-13T05:27:43.000Z","path":"2019/01/13/CSS3新特性/","text":"CSS3 简介CSS 即层叠样式表（Cascading StyleSheet）CSS3 是 CSS 技术的升级版本，CSS3 语言开发是朝着模块化发展的模块包括： 盒子模型、列表模块、超链接方式 、语言模块 、背景和边框 、文字特效 、多栏布局等CSS 用于控制网页的样式和布局。CSS3 是最新的 CSS 标准。CSS3 完全向后兼容，因此不必改变现有的设计。浏览器通常支持 CSS2。 CSS3 到底给我们带来了哪些新特性？CSS3 把很多以前需要使用图片和脚本来实现的效果，只需要短短几行代码就能搞定。比如圆角，图片边框，文字阴影和盒阴影、渐变等。CSS3 不仅能简化前端开发工作人员的设计过程，还能加快页面载入速度。 CSS3 选择器如果你在尝试实现一个干净的、轻量级的标签以及结构与表现更好的分离，高级选择器是非常有用的。它们可以减少在标签中的 class 和 ID 的数量并让设计师更方便的维护样式表。 属性选择器e[type=”text”] {} e[type*=””] e[type^=””] e[type$=””]伪类选择器结构性伪类选择器 div:first-child div:last-child div:nth-child(even)目标伪类选择器 p:target{}UI 元素状态伪类选择器 :enabled :disabled :checked ::selection语言伪类选择器 :lang(mingzi){}否定伪类选择器 div:not(标签)动态伪类选择器 input:focus{} 属性选择器在 css3 中，增加了如下所示的四个属性选择器，使得属性选择器有了通配符的概念。 标签[属性名=“value”] 匹配属性等于某特定值的元素标签[属性名^=&quot;value&quot;] 匹配属性包含以特定的值开头的元素标签[属性名$=&quot;value&quot;] 匹配属性包含以特定的值结尾的元素标签[属性名*=“value”] 匹配属性包含含有特定的值的元素 浏览器支持:只有 IE6 不支持 CSS 的属性选择器。IE7 和 IE8、Opera、Webkit 核心和 Gecko 核心的浏览器都支持。所以在样式中使用属性选择器是比较安全的 伪元素选择器 :first-line伪元素选择器first-line伪元素选择器用于向某个元素中的第一行文字使用样式 :first-letter伪元素选择器 first-letter伪元素选择器用于向某个元素中的文字的首字母（欧美文字）或第一个字（中文或者是日文等汉字）使用样式。 :before伪元素选择器before伪元素选择器用于在某个元素之前插入一些内容。 :after伪元素选择器after伪元素选择器用于在某个元素之后插入内容。 结构性伪类选择器E:first-child 选择第一个子元素 EE:last-child 选择最后一个子元素 EE:nth-child(n) 选择一个或多个特定的子元素 （第一个编号为 1）E:nth-last-child(n) 选择一个或多个特定的子元素，从最后一个子元素开始算E:nth-of-type(n) 选择指定的元素，仅匹配使用同种标签的元素E:nth-last-of-type(n) 选择指定的元素，从元素的最后一个开始计算，仅匹配使用同种标签的元素Nth-of-type(odd)奇数 Nth-of-type(even)偶数E:first-of-type 匹配父元素下使用同种标签的第一个子元素E:last-of-type 匹配父元素下使用同种标签的最后一个子元素E:only-child 匹配父元素下仅有的一个子元素E:only-of-type 匹配父元素下使用同种标签的唯一一个子元素E:empty 匹配一个不包含任何子元素的元素 ( 文本内容也被看作子元素 ):not(e) 匹配不符合当前选择器的任何元素( 反选 ) 目标伪类选择器标签:target：匹配 URl 中锚点指定的元素，用此选择器可以给锚点指定的元素加样式语法： Div:target{属性:属性值;} UI 元素状态伪类选择器这些选择器的共同特征是：指定的样式只有当元素处于某种状态下时才起作用，在默认状态下不起作用 E:enabled 匹配表单中可用的元素E:disabled 匹配表单中禁用的元素E:checked 匹配表单中被选中的 radio（单选框）或 checkbox（复选框）元素E::selection 用来改变浏览网页选中文本的默认效果基本上只有 background 、color 有效果 语言伪类选择器语言伪类选择器允许为不同的语言定义特殊的规则，这在多语言版本的网站用起来是特别的方便。E:lang(language)表示选择匹配 E 的所有元素，且匹配元素指定了 lang 属性，而且其值为 language。 12345&lt;style&gt; p:lang(en) &#123; background: yellow; &#125;&lt;/style&gt; 否定伪类选择器如果想对某个结构元素使用样式，但是想排除这个结构元素下面的子结构元素，让它不使用整个样式时，可以使用 not 选择器 :not(标签)：不匹配选择符为 s 的元素。 动态伪类选择器123456789101112a:link &#123; color: #ff6600;&#125; /* 未被访问的链接 */a:visited &#123; color: #87b291;&#125; /* 已被访问的链接 */a:hover &#123; color: #6535b2;&#125; /* 鼠标指针移动到链接上 */a:active &#123; color: #55b28e;&#125; /* 正在被点击的链接 */ a:active 用于用户点击元素那一下的效果（正发生在点的那一下，松开鼠标左键此动作也就完成了）input:focus 用于元素成为焦点，这个经常用在表单元素上。 在 CSS 定义中，a:hover 必须被置于 a:link 和 a:visited 之后，才是有效的。在 CSS 定义中，a:active 必须被置于 a:hover 之后，才是有效的。 层级选择器子元素选择器 E &gt; F E 元素内的第一级子元素 F 兄弟选择器 E + F(相邻兄弟) E 元素后面的第一个兄弟元素 FE ~ F（通用兄弟） 所有在 E 元素之后的兄弟元素 F 浏览器前缀介绍CSS3 属性都需要带各浏览器的前缀，甚至到现在，依然还有很多属性需要带前缀。浏览器厂商以前就一直在实施 CSS3，但它还未成为真正的标准。为此，当一些 CSS3 样式语法还存在波动时，就提供了针对浏览器的前缀来表示它们的私有属性； Gecko （火狐）前缀-moz-属性名：属性值；Presto （欧朋）前缀-o-Trident （IE）前缀-ms-Webkit （苹果、谷歌）前缀-webkit- CSS3 优雅降级和渐进增强问题渐进增强（Progressive Enhancement）：一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验。 优雅降级（Graceful Degradation）：一开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用 CSS3 的特性构建了一个应用，然后逐步针对各大浏览器进行 hack 的修改使其可以在低版本浏览器上正常浏览。 CSS3 新增的部分属性关于文本的文本阴影：text-shadow文本换行: Word-wrap 、 Word-breakCSS3 服务器端字体： @font-face 关于背景的Background-origin 背景原点Background-clip 背景裁切Background-size 背景尺寸 关于边框的Border-color 边框颜色Border-image 图片边框Border-radius 圆角边框Box-shadow 盒子阴影 CSS3 新增的关于文本的属性文本阴影：text-shadow: h-shadow v-shadow blur color h-shadow 必需。水平阴影的位置。允许负值;v-shadow 必需。垂直阴影的位置。允许负值。blur 可选。模糊的距离。color 可选。阴影的颜色。 是否允许长单词换行：word-wrap:normal \\ break-word normal 默认值，只在允许的断字点换行;break-word 在长单词或 URL 地址内部进行换行。 是否允许长单词换行(加上后单词不会另起一行显示)：word-break:normal\\ break-all normal 使用浏览器默认的换行规则Break-all 允许在单词内换行。 注释：目前 Opera 不支持 word-break 属性 服务器端字体： @font-face可将该字体文件存放到 web 服务器上，它会在需要时被自动下载到用户的计算机上 使用方法： 1234567@font-face &#123; font-family: webFont; src: url(‘font/字体名称.otf’) ；;&#125; Div &#123; font-family: webFont;&#125; 字体图标的使用 阿里文字图标的加载步骤 先从阿里图标库下载图标； 把文件放到站点中，可以建一个 font 文件夹 把 iconfont.css 文件导入到 html 文件中； 在 html 文档中写一个内联元素如 span 标签,加 class=”iconfont 图标对应 class 名” 1&lt;span class=\"iconfont icon-shouji\"&gt;&lt;/span&gt; CSS3 新增的关于背景的属性背景裁切：Background-clip； 用来规定背景的绘制区域（对于背景颜色） border-box 背景被裁剪到边框盒。padding-box 背景被裁剪到内边距框。content-box 背景被裁剪到内容框。 背景原点：Background-origin；用来规定 background-position 属性相对于什么位置来定位（对于背景图片） padding-box 背景图像相对于内边距框来定位。border-box 背景图像相对于边框盒来定位。content-box 背景图像相对于内容框来定位。 背景尺寸：Background-size； 用来规定背景图像的尺寸数值 设置背景图片高度和宽度。第一个值设置宽度，第二个值设置的高度。如果只给出一个值，第二个是设置为 auto(自动)百分比 将计算相对于背景定位区域的百分比。第一个值设置宽度，第二个值设置的高度。如果只给出一个值，第二个是设置为”auto(自动)”cover 把背景图像等比例扩大或缩小，以使背景图像完全覆盖背景区域。背景图像的某些部分也许无法显示在背景定位区域中。contain 把图像扩大或缩小至合适尺寸，以使其宽度或高度完全适应内容区域 CSS3 多背景属性多个背景图可用逗号隔开 123background: url(…) no-repeat left top, url(…) no-repeat left top, url(…) no-repeat left top, url(…) no-repeat left top, url(…) no-repeat left top; CSS3 背景颜色模式rgba（r:红色；g：绿色；b:蓝色；a：alpha）Hsl 颜色模式（色调，饱和度，亮度）如： 0 代表红色，120 代表绿色，240 代表蓝色Hsla (色调，饱和度，亮度，透明度) Background:rgba(0,0,0,1) 表示黑色，不透明Background:hsla(8,97%,98%,0.5) Border-color 边框颜色 border:2px solid #f00; table {border-color: red} - 所有的边框都是红色。table {border-color: red green} - 上边框和下边框是红色，而左边框和右边框是绿色。table {border-color: red green blue}- 上边框是红色，左边框和右边框是绿色，下是蓝色table {border-color: red green blue yellow} - 上边框是红色，右边框是绿色，下边框是蓝色，左边框是黄色。 Border-width: 边框粗细；Border-style: 边框线性 CSS3 新增的关于边框的属性Border-radius:圆角边框 123456Border-radius:5px;Border-radius:50%;Border-radius:20px 20px;Border-radius:40px 0px 30px ;border-radius:5px 15px 20px 25px ;border-radius:20px / 10px ; （扩展） 透明色：transparent Box-shadow 盒子阴影 h-shadow 必需。水平阴影的位置。允许负值。v-shadow 必需。垂直阴影的位置。允许负值。blur 可选。模糊距离。spread 可选。阴影的尺寸。color 可选。阴影的颜色。请参阅 CSS 颜色值。inset 可选。将外部阴影 (outset) 改为内部阴影。 例：p{box-shadow:0px 0px 5px 5px rgba(153,153,238,1);}p{box-shadow:5px 0px 5px 5px rgba(153,153,238,1);}p{box-shadow:-5px 0px 5px 0px rgba(153,153,238,1);} 图片边框：border-imageborder-image-source 用在边框的图片的路径。border-image-slice 图片边框向内偏移。border-image-width 图片边框的宽度。border-image-outset 边框图像区域超出边框的量。border-image-repeat 图像边框是否应平铺(repeat)、铺满(round)或拉伸(stretch)。 缩写：border-image:url(img/border.png) 30 round; border-image-source: url(img/border.png);border-image-slice: 30; （不需要加单位单位默认是 px）border-image-width: initial;border-image-outset: initial;border-image-repeat: round; 本文作者：人模人样的搬砖老段本文链接：CSS3 新特性如有错误，请及时评论或者知乎私信或者 B 站私信哦~ 最后更新于:2020/03/22","tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/tags/CSS3/"}]},{"title":"BFC","date":"2018-12-29T17:02:10.000Z","path":"2018/12/30/BFC/","text":"什么是 BFCBFC(Block formatting context)译为”块格式化上下文”，是一个独立的渲染区域，规定了内部的子元素如何布局，并且与这个区域外部毫不相干。 哪些元素会生成 BFC 根元素 html float 属性不为 none position 为 absolute 或 fixed display 为 inline-block, table-cell, table-caption, flex, inline-flex overflow 不为 visible（除非该值已经被传播到视口） BFC 布局规则是怎样的 内部的 Box 会在垂直方向，一个接一个地放置。 Box 垂直方向的距离由 margin 决定。属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠 每个元素的 margin box 的左边， 与包含块 border box 的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。 BFC 的区域不会与 float box 重叠。 BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 计算 BFC 的高度时，浮动元素也参与计算 并不是只有块元素才会生成 BFC，任何元素只要符合条件即可生成 BFC BFC 的应用 自适应两栏布局 清除内部浮动 防止 margin 上下重叠 本文作者：人模人样的搬砖老段本文链接：BFC如有错误，请及时评论或者知乎私信或者 B 站私信哦~ 最后更新于:2019/10/21","tags":[{"name":"BFC","slug":"BFC","permalink":"http://yoursite.com/tags/BFC/"}]},{"title":"浏览器兼容和精灵图","date":"2018-12-16T15:20:03.000Z","path":"2018/12/16/浏览器兼容和精灵图/","text":"浏览器相关 浏览器内核 浏览器最关键的部分就是它的渲染引擎（Rendering Engine），也就是大家平常所说的的“内核”。 五大浏览器内核Trident （MSHTML） （三叉戟；三叉线；三齿鱼叉）Gecko （壁虎）Presto （ 迅速的）Webkit （Safari 内核,Chrome 内核原型,它是苹果公司自己的内核，也是苹果的 Safari 浏览器使用的内核）Blink (由 Google 和 Opera Software 开发的浏览器排版引擎) 浏览器内核代表浏览器 Trident:IE、Maxthon(遨游)、腾讯 、Theworld 世界之窗、360 浏览器代表作品 IE,因为 IE 捆绑在 Windows 中，所以占有极高的市场份额，又称 IE 内核或是 MSHTML，此内核只能应用于 windows 平台，且是不开源的。 Gecko:代表作品 Mozilla Firefox 是开源的,它的最大优势是跨平台，能在 Microsoft Windows、Linux 和 MacOS X 等主要操作系统上运行。 Webkit:代表作品 Safari、Chrome ， 是一个开源项目。 Presto:代表作品 Opera ，Presto 是由 Opera Software 开发的浏览器排版引擎。它也是世界上公认的渲染速度最快的引擎。 Blink:由 Google 和 Opera Software 开发的浏览器排版引擎，2013 年 4 月发布。 CSS 兼容问题 样式在各浏览器中解析不一致的情况，或者说 CSS 样式在浏览器中不能正确显示的问题称为 CSS bug. CSS Hack: CSS 中，Hack 是指一种兼容 CSS 在不同浏览器中正确显示的技巧方法，修补 bug 的方法 Filter:表示过滤器的意思，它是一种对特定的浏览器或浏览器组显示或隐藏规则或声明的方法。本质上讲，Filter 是 hack 方法中的一种； IE6 常见 CSS 解析 Bug 及 hack（解决方法） 默认高度（IE6）描述：在 IE6 及以下版本中，部分块元素拥有默认高度（低于 18px 高度）hack1:给元素添加声明：font-size:0;hack2：给元素添加声明：overflow:hidden; 图片间隙div 中的图片间隙bug：在块元素中插入图片时，有时图片会将块元素下方撑大三像素。Hack：给&lt;img&gt;添加声明：display:block; vertical-align:middle 双倍浮向（双倍边距）描述：当 Ie6 及更低版本浏览器在解析浮动元素时，会错误地把浮向边的边界加倍显示。hack:给浮动元素添加声明：display:inline; 表单元素行高不一致(IE,MOZ,C,O,S)bug：表单元素行高对齐方式不一致hack:给表单元素添加声明：float:left; 按钮元素默认大小及样式不一致hack1:统一大小及样式/（用 a 标记模拟）hack2:input 外边套一个标签，在这个标签里写按钮的样式，把 input 的边框去掉。hack3:如果这个按钮是一个图片，直接把图片作为按钮的背景图即可。 百分比 bug描述：在 IE6 及以下版本中在解析百分比时，会按四舍五入方式计算从而导致 50%加 50%大于 100%的情况。hack:给右面的浮动元素添加声明：clear:right; 意思：清除右浮动。clear:left 清除左浮动clear:both 清除两边的浮动 鼠标指针 bug描述：cursor 属性的 hand 属性值只有 IE8 浏览器识别;hack:如统一某元素鼠标指针形状为手型，应添加声明：cursor:pointer;cursor 的值有:auto 默认crosshair 加号text 文本wait 等待help 帮助progress 过程inherit 继承move 移动ne-resize 向上或向右移动pointer 手形 透明属性IE 浏览器写法：filter:alpha(opacity=数值);取值范围 1-100(IE8 以下)兼容其他浏览器写法：opacity:数值;(数值的取值范围 0-1,0.1,0.2,0.3—–0.9) 当 li 里的 A 加 display:block 或 float:left 时，出现行高不一致，有的会多出 3 像素；hack1：给 a 加display:inline-block;Hack3：给 li 加 float，并加宽度； 当 li 加 float 属性，并且 li 里的 A 转换成块元素,并给 a 加了高度时，IE6 里会出现每个 LI 单独占一行或阶梯状的情况；hack1：不给 a 标签加高度；Hack2：给 a 标签也添加 float； 父元素里有块元素，如果给子元素添加添加margin-top,父元素会下来。Hack1：给父元素添加overflow:hidden;Hack2：给子元素添加 float；Hack3：给父元素加边框； 或者用其他的方法达到我们想要的效果：如给父元素加padding-top 图片整合(精灵图)用 background-position”来实现背景图片的定位技术,这种技术可以成为 css sprites 技术，又称为 css 精灵。 将导航背景图片，按钮、背景小图标等小图片有规则的合并成一张背景图，即将多张图片合为一张整图，再利用 background 属性进行背景定位，用数字精确的定位出背景图片在布局盒子中的位置； 优点: 1)通过图片整合来减少对服务器的请求次数，从而提高 页面的加载速度。 2)通过整合图片来减小图片的体积。 注意点: 1)根据实际容器的大小，小图片和小图片之间要留有足够的空间 2)开发和修改时需要精确测量每一个背景单元的精确位置，测量和修改起来比较麻烦。 滑动门技术: 什么是滑动门滑动门是一个形象的称呼，它利用 CSS 背景图像可层叠性，并允许彼此之上进行滑动来创造一些特殊动态效果 滑动门特征通过滑动门技术，可以使 CSS 设计出来的导航菜单兼具传统布局的图像效果，与 CSS 布局的高效扩展性 。 本文作者：人模人样的搬砖老段本文链接：浏览器兼容和精灵图如有错误，请及时评论或者知乎私信或者 B 站私信哦~ 最后更新于:2019/01/21","tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"浏览器内核","slug":"浏览器内核","permalink":"http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8/"},{"name":"浏览器兼容","slug":"浏览器兼容","permalink":"http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9/"},{"name":"精灵图","slug":"精灵图","permalink":"http://yoursite.com/tags/%E7%B2%BE%E7%81%B5%E5%9B%BE/"}]},{"title":"表单表格高级","date":"2018-12-02T09:05:56.000Z","path":"2018/12/02/表单表格高级/","text":"表单相关的标签 表单元素 1)单选按钮 1&lt;input type=\"radio\" name=\"mal\" /&gt; 2)复选框 1&lt;input type=\"checkbox\" disabled checked /&gt; 3)下拉菜单 123&lt;select&gt; &lt;option&gt;&lt;/option&gt;&lt;/select&gt; 4)多行文本输入框 1&lt;textarea cols=\"\" rows=\"\"&gt;&lt;/textarea&gt; 5)上传文件框 1&lt;input type=\"file\" /&gt; 6)图像域（图片按钮） 1&lt;input type=\"image\" width=\"100\" height=\"100\" alt=\"\" src=\"路径\" /&gt; 表单字段集&lt;fieldset&gt;&lt;/fieldset&gt;功能：相当于一个方框，在字段集中可以包含文本和其他元素。该元素用于对表单中的元素进行分组，并在文档中区别标出文本。fieldset 元素可以嵌套，在其内部可以在设置多个 fieldset 对象。 字段级标题&lt;legend&gt;&lt;/legend&gt;功能：legend 元素可以在 fieldset 对象绘制的方框内插入一个标题。legend 元素必须是 fieldset 内的第一个元素。 提示信息标签&lt;label for=&quot;绑定控件id名&quot;&gt;&lt;/label&gt;功能：label 元素用来定义标签，为页面上的其他元素指定提示信息。要将 label 元素绑定到其他的控件上，可以将 label 元素的 for 属性设置为与该控件的 id 属性值相同。 关于表格的 CSS 属性 单元格间距(该属性必须给 table 添加)border-spacing:value; 合并相邻单元格边框border-collapse:separate(边框分开)/collapse(边框合并)；（写 1 像素边框表格） 无内容单元格显示、隐藏empty-cells:show/hide; 表格布局算法table-layout:auto/fixed(固定宽度，不会随内容多少改变单元格宽度）自动表格布局：列的宽度是由列单元格中没有折行的最宽的内容设定的。缺点：较慢（因为它需要在确定最终的布局前访问表格中的所有内容）。优点：灵活固定表格布局优点：加快运行的速度,允许浏览器更快的对表格进行布局。缺点:不太灵活 表格标题&lt;caption&gt;标题内容&lt;/caption&gt;表格标题位置：caption-side:top/right/bottom/left说明：left,right 位置只有火狐识别，top,bottom IE7 上版本支持，ie7 以下版本不支持其它属性值，只识别 top 表格布局元素 表格基本组成table（表格） tr（行） td（列）th:表格列标题（放在 tr 里）重要属性： 1)colspan=&quot;value&quot; 合并列2)rowspan=&quot;value&quot; 和并行 3)valign=&quot;top/bottom/middle&quot; 垂直对齐方式 align=left/center/right 水平对齐方式 4)rules=&quot;groups/rows/cols/all/none&quot; 添加组分隔线说明：rows:位于行之间的线条cols:位于列之间的线条all：位于行和列之间的线条none:没有线条groups:位于行组和列组之间的线条 数据行分组&lt;thead&gt;&lt;/thead&gt; 表头&lt;tbody&gt;&lt;/tbody&gt; 表体&lt;tfoot&gt;&lt;/tfoot&gt; 表尾说明:一个 Table 中，只能包含一个 thead,一个 tfoot,但可包含多个 tbody。不会影响到表格的布局。 数据列分组 12&lt;colgroup span=\"value\"&gt;&lt;/colgroup&gt;&lt;col span=\"value\" /&gt; 说明：1）col 和 colgroup 元素会根据从左到右的顺序依次对数据表格进行分组。2）span 属性显示指定相邻几列组成一组，span 属性值默认为 1，默认时仅定义一列为一组。3）可以通过给 table 添加rules=&quot;groups&quot;属性来给分组列添加组分割线。注意：虽然 col 和 colgroup 具有相同的功能，但是，我们只能使用 colgroup 元素来决定表格内容部分分割线（rules）应该处于的位置，而 col 没有这个功能。 本文作者：人模人样的搬砖老段本文链接：表单表格高级如有错误，请及时评论或者知乎私信或者 B 站私信哦~ 最后更新于:2020/05/19","tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"表格高级","slug":"表格高级","permalink":"http://yoursite.com/tags/%E8%A1%A8%E6%A0%BC%E9%AB%98%E7%BA%A7/"},{"name":"表单高级","slug":"表单高级","permalink":"http://yoursite.com/tags/%E8%A1%A8%E5%8D%95%E9%AB%98%E7%BA%A7/"}]},{"title":"H5新增元素和属性","date":"2018-11-18T11:51:13.000Z","path":"2018/11/18/H5新增元素和属性/","text":"HTML5 的特点 自适应网页设计 语法更宽松 多设备跨平台 标签语义化 结构更简单、清晰 语义化的重要性： 1)当页面加载失败的时候，还能够呈现出清晰的结构 2)有利于 SEO 优化，利于被搜索引擎收录（即 便于网络爬虫的识别） 3)在项目开发及维护时，语义化也很大程度上降低了开发难度，节省成本 HTML5 新增的结构标签 headerheader 标签定义文档或者文档的一部分区域的页眉。一般作为介绍内容或者导航链接栏的容器。在一个文档中，可以定义多个&lt;header&gt;元素。注：&lt;header&gt; 标签不能被放在 &lt;footer&gt;、&lt;address&gt; 或者另一个 &lt;header&gt; 元素内部。 navnav 定义页面中导航链接部分(传统导航条、腾讯新闻、侧边栏导航、内页导航、百度百科、翻页操作)注：并不一定是视觉上的导航，只要是多链接区域，都可以使用 artical&lt;article&gt; 标签定义独立的内容。内容本身必须是有意义的且必须是独立于文档的其余部分。如：论坛帖子、博客文章、新闻故事、评论 aside&lt;aside&gt; 标签定义 &lt;article&gt; 标签外的内容。应该与附近的内容相关。 section&lt;section&gt; 标签定义了文档的某个区域。比如章节、头部、底部或者文档的其他区域。标示文档的结构 footer&lt;footer&gt; 标签定义文档或者文档的一部分区域的页脚。如：文档创作者的姓名、文档的版权信息、使用条款的链接、联系信息等等。在一个文档中，您可以定义多个 &lt;footer&gt; 元素。 figure定义一段独立的流内容，一般是文档主体流内容中的一个独立单元。使用 figcaption 元素为 figure 元素添加标题。figure 是一种元素的组合，带有可选标题。用来表示网页上一块独立内容。figcaption 表示 figure 的标题。从属于 figure，并且，figure 中只能放置一个 figcaption注：有默认的边距或填充值 hgroup表示定义文件中一个区块的相关信息，一般用作放置标题标签的容器。 dialog&lt;dialog&gt; 标签定义一个对话框、确认框或窗口注：目前，只有 Chrome 和 Safari 6 支持 &lt;dialog&gt; 标签。 新增的多媒体元素 video 元素在 HTML5 中专门用来播放网络上的视频或者电影。使用方法:video 元素要设定好长宽和 src 属性就可以了： 1&lt;video width=\"750\" height=\"400\" src=\"time.mp4\" controls=\"controls\"&gt;&lt;/video&gt; 同样对于不支持 video 的浏览器可以在中间加入替换文字： 1&lt;video width=\"750\" height=\"400\" src=\"time.mp4\"&gt;您的浏览器不支持video元素&lt;/video&gt; audio 元素在 HTML5 中专门用来播放网络上的音频使用方法:audio 元素只需要给他指定一个 src 属性： 1&lt;audio src=\"MP3.mp3\" controls=\"controls\"&gt;&lt;/audio&gt; 对于不支持的浏览器我们可以在这对元素之间加入提示语句来代替 1&lt;audio src=\"MP3.mp3\" controls=\"controls\"&gt;您的浏览器不支持Audio元素&lt;/audio&gt; source 元素指定多个播放格式与编码：source 元素可以为同一个媒体数据指定多个播放格式与编码方式，以确保浏览器可以从中选择一种自己支持的播放格式进行播放。选择顺序自上而下，直到选择到所支持的格式为止。使用方法： 12345&lt;video&gt; &lt;source src=\"video.webm\" type=\"video/webm\" /&gt; &lt;source src=\"video.ogg\" type=\"video/ogg\" /&gt; &lt;source src=\"video.mp4\" /&gt;&lt;/video&gt; 注：video 元素支持三种视频格式：mp4、ogg、webm; 浏览器的支持：Safari3 以上、Firefox4 以上、0pera10 以上、chrome3.0 以上版本都对 audio 元素和 video 元素支持！ 新增的其他元素canvas表示图形，比如图标和其他图像。这个元素本身没有行为，仅提供一块画布，但它把一个绘图 API 展现给客户端 js，以使脚本能够把想绘制的东西绘制到这块画布上 1&lt;canvas id=\"myCanvas\" width=\"200\" height=\"200\"&gt;&lt;/canvas&gt; 新增的表单元素 Datalistdatalist 提供一个事先定义好的列表，通过 id 与 input 关联，当在 input 内输入时就会有自动完成的功能，用户将会看见一个下拉列表供其选择。选项列表 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;HTML5 datalist tag&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;浏览器版本：&lt;input list=\"words\" /&gt;&lt;/p&gt; &lt;datalist id=\"words\"&gt; &lt;option value=\"浏览器\" /&gt; &lt;option value=\"Firefox\" /&gt; &lt;option value=\"Chrome\" /&gt; &lt;option value=\"Opera\" /&gt; &lt;option value=\"Safari\" /&gt; &lt;option value=\"Sogou\" /&gt; &lt;option value=\"Maxthon\" /&gt; &lt;/datalist&gt; &lt;/body&gt;&lt;/html&gt; output表示不同类型的输出，比如脚本的输出 注：表单中有应用 新增的表单类型 email专门用来输入 email 地址的文本框,如果该文本框中内容不是 email 地址格式的，则不允许提交。但它不检查 email 地址是否存在。提交时可以为空，除非加上了 required 属性。 具有 multiple 属性，它允许在该文本框中输入一串以逗号分隔的 email 地址。 url专门用来输入 URL 地址的文本框。如果该文本框中内容不是 URL 地址格式的，则不允许提交。例： 1&lt;input name=\"url1\" type=\"ur\" value=\"http://www.baidu.com\" /&gt; number 和 rangenumber 类型是专门用来输入数字的，并且在提交时会检验是否为数字。number 类型有 max、min 和 step 属性。max 是允许的最大值，min 是允许的最小值，step 是间隔。设置了这些属性后，如果手动填入的数字不符合这些属性条件，将不能提交。 range 类型是一个数字滑动条。它与 number 类型功能类似，也有 max、min 和 step 属性，在 Opera 中，可以用左右方向键控制。range 类型自身没有一个明显的“数值”表示当前值，但可以使用 output 输出当前值。 datetime 和 datetime-localdatetime 类型是用来输入 UTC 日期和时间的文本框，而 datetime-local 类型是用来输入本地日期和时间的。它们与 date 类型的区别是后面多了一个时间框和“UTC”。 month 和 weekmonth 类型是月份选择器，它的值为：年-月，如：2012-01；week 类型是周选择器，它的值为：年-W 周数，如:2011-W02。 searchsearch 类型的是用来输入搜索关键词的文本框，它与 text 类型在功能都没有太大区别，只在外观上有细微的区别。在 Chrome 10 和 Safari 5 中，当用户输入内容时，输入框右侧会有一个“×”按钮，单击该按钮，将清空输入框内的内容，使用非常方便。 colorcolor 类型用来选取颜色，它提供了一个颜色选取器，值为 16 进制符号，如：#ff0000。目前只在 Opera 和 Blackberry 浏览器中支持。 注意，跟 input 标签设置样式一样，但是要设置标签中局部的样式不能实现。如改变日历的背景色，颜色框的按钮效果，等，这些都不可以实现。 output 元素：定义不同类型的输出，如计算结果的输出，或脚本的输出。注：必须从属于某个表单。即，必须将它书写在表单内部，或对它添加 form 属性。 12345&lt;form oninput=\"x.value=parseInt(a.value)+parseInt(b.value)\"&gt; 0 &lt;input type=\"range\" id=\"a\" value=\"50\" /&gt;100+ &lt;input type=\"number\" id=\"b\" value=\"50\" /&gt;= &lt;output name=\"x\" for=\"a b\"&gt;&lt;/output&gt;&lt;/form&gt; date从日期选择器选择一个日期 time输入事件的文本框 tel输入电话号码 新增的 input 属性 required可以应用在大多数输入元素上,在提交时如果元素内容为空白，则不允许提交，同时显示提示文字。 pattern此属性用来设置某个格式的正则表达式，在提交时会检查其内容是否符合给定格式。 12345&lt;input type=\"text\" pattern=\"[0-9][A-Z]&#123;3&#125;\" placeholder=\"输入内容：一个数与三个大写字母\"/&gt; placeholder 属性文本框处于未输入状态时文本框中显示的输入提示。 autofocus 属性给文本框、选择框、或者按钮控件加上该属性，当打开页面时，该控件自动获得鼠标焦点，一个页面只能有一个。 autocomplete 属性规定输入字段是否应该启用自动完成功能。属性值=on/off自动完成允许浏览器预测对字段的输入。当用户在字段开始键入时，浏览器基于之前键入过的值，应该显示出在字段中填写的选项。使用时表单元素必须有 name 属性；（类似历史记录功能） 注释：autocomplete 属性适用于 &lt;form&gt;，以及下面的 &lt;input&gt; 类型：text, search, url, telephone, email, password, datepickers, range 以及 color。 提示：在某些浏览器中，可能需要手动启用自动完成功能。 min、max、step：为包含数字或日期的 input 类型规定限定（约束）max: 最大值min: 最小值step: 数字间隔 1&lt;input type=\"number\" min=\"0\" max=\"10\" step=\"3\" /&gt; 取消验证可以对 form 表单添加 novalidate 属性，即使 form 表单中的 input 添加了 required，也将不进行验证 Multiple可以输入一个或多个值，每个值之间用逗号分开；如果要获取其中的值在用 split 获取； 1&lt;input type=\"email\" multiple /&gt; 还可以应用于 file 本文作者：人模人样的搬砖老段本文链接：H5 新增元素和属性如有错误，请及时评论或者知乎私信或者 B 站私信哦~ 最后更新于:2020/01/12","tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"HTML5","slug":"HTML5","permalink":"http://yoursite.com/tags/HTML5/"}]},{"title":"宽高自适应","date":"2018-11-04T09:58:46.000Z","path":"2018/11/04/宽高自适应/","text":"宽高自适应定义：网页布局中经常要定义元素的宽和高。但很多时候我们希望元素的大小能够根据窗口或子元素自动调整，这就是自适应。优点：元素自适应在网页布局中非常重要，它能够使网页显示更灵活，可以适应在不同设备、不同窗口和不同分辨率下显示。 宽度自适应子元素的宽度自动适应父元素的宽度子元素元素宽度设置为 100%。（块元素宽度默认为 auto） 高度自适应 1)元素高度自适应窗口高度设置方法：html,body{height:100%;}（写一个满屏页面） 2)子元素自适应父元素高度：height:100%; 元素具备最小高度的自适应属性：最小高度；(IE6 浏览器不识别该属性)min-height什么时候用？当元素内容的高度不确定的时候用min-height;最小高度兼容 IE6 的写法：方法 1:min-height:value; _height:value;方法 2:min-height:value; height:auto!important;height:value; (属性顺序不能改变，建议使用) !important关键字过滤器，写在属性值的后面，加上此单词,属性具有最高的优先级，但是 ie6 不能识别此关键字； min-height（最小高度,设置此属性后，内容高度小于此高度,显示此高度；大于容器高度时，容器自适应高度；） max-height(最大高度，设置此属性后，内容高度小于此高度时，显示内容高度；内容高度超过此高度时显示此高度) min-width(最小宽度,设置此宽度后，浏览器宽度小于此宽度时显示滚动条，大于此宽度时，适应浏览器宽度；) max-width(最大宽度，设置此属性后浏览器宽度小于此容器时，会适应内容宽度而不出现滚动条) 清除浮动浮动元素父元素高度自适应（父元素不写高度时，所有子元素写了浮动后，父元素会发生高度塌陷） hack1：给父元素添加声明overflow:hidden;（缺点：当子元素有定位设置，定位到父元素外面时，不希望溢出父元素部分隐藏时，此方法就不行了） hack2:在最后一个浮动元素下方添加空 div,并给该元素添加声明：clear:both;height:0;overflow:hidden;（缺点：在 HTML 结构文档中会形成很多冗余代码） hack3:万能清除浮动法父元素选择符:after{content:&quot;.&quot;;clear:both;display:block;height:0;overflow:hidden;visibility:hidden;} 伪对象选择符 :after与 content 属性一起使用，定义在对象后的内容。如: 123456div:after &#123; content: url(logo.jpg);&#125;div:after &#123; content: \"文本内容\";&#125; :before与 content 属性一起使用，定义在对象前的内容。如: 123div:before &#123; content: \"在其前放内容\";&#125; :first-letter定义对象内第一个字符的样式。 :first-line定义对象内第一行的样式。 说明：该伪元素只能用于块级元素。ie6 及以下版本浏览器不支持伪对象选择符。 控制元素隐藏/可见visibility:hidden/visible;隐藏/可见 visibility:hidden;和display:none;的区别：visibility:hidden;属性会使对象不可见，但该对象在网页所占的空间没有改变，等于留出了一块空白区域，而 display:none属性会使这个对象彻底消失。 总结 站点中的新闻详情页面和产品详情页面中的详细内容部分高度一般都是不固定的，这时需要用 min-height; 这就导致详细内容部分的父元素高度也不能固定，如父元素中还有子元素发生了浮动，这时父元素就可能发生高度塌陷，如果高度塌陷的话就需要清除浮动； 一般新闻详情页面和产品详情页面都会出现这种情况 Fliter（过滤器）方法兼容浏览器 *下划线：IE6 浏览器的兼容符号； （只有 IE6 浏览器识别此符号，其他浏览器不识别）语法：选择器{*属性:属性值;} *或+：兼容所有 IE7 以下浏览器；（只有 IE7 及以下版本浏览器识别此符号，其他浏览器不识别）语法：选择器{*属性:属性值; +属性:属性值;} \\0：IE8 及以上浏览器的兼容符号；语法：选择器{属性:属性值\\0;} \\9：兼容所有 IE 浏览器；语法：选择器{属性:属性值\\9}（只有 IE 浏览器识别此符号，其他浏览器不识别） 本文作者：人模人样的搬砖老段本文链接：宽高自适应如有错误，请及时评论或者知乎私信或者 B 站私信哦~ 最后更新于:2020/01/12","tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"宽高自适应","slug":"宽高自适应","permalink":"http://yoursite.com/tags/%E5%AE%BD%E9%AB%98%E8%87%AA%E9%80%82%E5%BA%94/"}]},{"title":"盒模型","date":"2018-10-21T05:49:29.000Z","path":"2018/10/21/盒模型/","text":"盒模型的概念css 定义的所有元素都可以拥有像盒子一样的外形和平面空间，它是 css 布局的基石，它规定了网页元素如何显示以及元素间相互关系。 盒模型的组成CSS 盒子模式都具备这些属性：内容(content)、填充(padding)、边框(border)、边界(margin) 用日常生活的盒子来理解这四个属性 内容（content）盒子里装的东西； 填充（padding）就是怕盒子里装的东西（贵重的）损坏而添加的泡沫或者其它抗震的辅料； 边框（border）盒子本身； 边界（margin）盒子与盒子之间的空隙，或者是大盒子与嵌套在里面的小盒子之间的空隙。 padding 属性padding 的定义 padding 是元素内容到元素边框之间的距离，叫内填充、补白或内边距 padding 区域内会显示背景色和背景图片 padding 的用法 用来调整内容在容器中的位置关系 用来调整子元素在父元素中的位置关系。（注：padding 属性需要添加在父元素上。） padding 值是额外加在元素原有大小之上的，如想保证元素大小不变，需从元素宽或高上减掉后添加的 padding 属性值。 四种表示形式一个值：padding:2px; 四周的填充都是 2px二个值：padding:10px 20px ; 上下 左右 三个值：padding:10px 20px 30px ; 上 左右 下四个值：padding:10px 20px 30px 40px; 上 右 下 左 margin 属性边界：margin,在元素外边的空白区域，被称为外边距。margin-left:左边界margin-right:右边界margin-top:上边界margin-bottom:下边界 属性值的 4 种方式:四个值：上 右 下 左三个值：上 左右 下二个值：上下 左右一个值：四个方向 12345margin: 2px; /*定义元素四边边界为2px*/margin: 2px 4px; /*定义元素上下边界为2px，左右边界为4px*/margin: 2px 4px 6px; /*定义元素上边界为2px，左右边界4px，下边界为6px，*/margin: 2px 4px 6px 8px; /*定义元素上、右边界为2px，下右边界为6px，左边界为8px*/margin: 0 auto; /*在浏览器中横向居中*/ 定义元素上、下边界为 2px说明：可单独设置一方向边界，如：margin-top:10px; border 的使用方法border:边框宽度 边框风格 边框颜色;例如：border:5px solid #f00 边框：border,网页中很多修饰性线条都是由边框来实现的边框宽度：border-width:边框颜色：border-color:边框样式：border-style:solid(实线)/dashed(虚线)dotted(点划线)double(双线) 元素总尺寸计算方法width 和 height 属性在 CSS 中，width 和 height 指的是内容区域的宽度和高度。注意：增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素的总尺寸。 盒子的实际大小：实际宽 =左右 margin+左右 border+左右 padding+width实际高 =上下 margin+上下 border+上下 padding+height 单行文本溢出显示省略号的方法 容器宽度：width:value； 强制文本在一行内显示: white-space:nowrap; 溢出内容为隐藏：overflow:hidden; 溢出文本显示省略号：text-overflow:ellipsis; 容器的溢出属性overflow:visible/hidden(隐藏)/scroll/auto(自动)/inherit;visible:默认值，hidden：溢出容器的部分会隐藏；scroll：强制出现滚动条，如果有溢出，滚动条可以滚动，显示隐藏的部分;auto：如果内容有溢出会显示滚动条，如果没有溢出就不显示滚动条；inherit：从父元素继承 overflow 属性的值。 空余空间white-space：normal/pre/nowrap/pre-wrap /pre-line /inherit该属性用来设置如何处理元素内的空白；normal：默认值，空白会被浏览器忽略，pre：空白会被浏览器保留，其行为方式类似 HTML 中的 pre 标签；nowrap:文本不会换行，文本会在同一行上继续，直到遇到换行标签为止；pre-wrap：保留空白符序列，但是正常的进行换行；pre-line:合并空白符序列，但是保留换行符；inherit：规定应该从父元素继承 White-space 属性的值；(ie 浏览器不支持此属性值) 文本溢出:text-overflow:clip/ellipsis取值：clip：不显示省略号（…），而是简单的裁切;ellipsis：当对象内文本溢出时，显示省略标记； 本文作者：人模人样的搬砖老段本文链接：盒模型如有错误，请及时评论或者知乎私信或者 B 站私信哦~ 最后更新于:2019/09/05","tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"盒模型","slug":"盒模型","permalink":"http://yoursite.com/tags/%E7%9B%92%E6%A8%A1%E5%9E%8B/"}]},{"title":"定位锚点","date":"2018-10-07T15:53:05.000Z","path":"2018/10/07/定位锚点/","text":"与定位相关的属性position：static /absolute/relative/fixed static：默认值，无特殊定位，对象遵循 HTML 原则； absolute：绝对定位，将对象从文档流中拖离出来，使用 left/right/top/bottom 属性相对其最接近的一个并有定位设置的父元素进行绝对定位；如果不存在这样的父对象，则依据 html 对象(浏览器)，而其层叠通过 z-index 属性定义； relative ：相对定位，相对于标签原来的位置进行定位，对依据 right，top，left，bottom（相对定位）等属性在正常文档流中偏移位置； fixed：固定定位：相对于浏览器定位，脱离文档流； 绝对定位与相对定位的区别 参照物不同绝对定位的参照物是包含块，相对定位的参照物是元素本身位置； 绝对定位将对象从文档流中拖离出来因此不占据空间，相对定位不破坏正常的文档流顺序无论是否进行移动，元素仍然占据空间。 包含块的概念及作用包含块是绝对定位的基础，包含块就是为绝对定位元素提供坐标，偏移和显示范围的参照物，即确定绝对定位的偏移起点和百分比 长度的参考；默认状态下，html 是一个大的包含块，所有绝对定位的元素都是根据窗口来定自己所处的位置和百分比大小的显示的，如果我们定义了包含元素为包含块以后，对于被包含的绝对定位元素来说，就会根据最接近的具有定位功能的上级包含元素来定位自己的显示位置。 定义父元素为包含块：给直接父元素添加声明 position：relative； 定位元素层叠属性z-index : auto | number检索或设置对象的层叠顺序。auto：默认值。遵从其父对象number:无单位的整数值。可为负数 较大 number 值的对象会覆盖在较小 number 值的对象之上。如两个绝对定位对象的此属性具有同样的 number 值，那么将依据它们在 HTML 文档中声明的顺序层叠。此属性仅仅作用于 position 属性值为 absolute/relative/fixed 的对象。 命名锚点链接 命名锚点的作用：在同一页面内的不同位置进行跳转。 给元素定义命名锚记名 1&lt;!-- &lt;标记 id=\"命名锚记名\"&gt;&lt;/标记&gt; --&gt; 命名锚记连接语法： 1&lt;a href=\"#命名锚记名称\"&gt;&lt;/a&gt; 元素透明兼容写法Filter:alpha(opacity=50);IE8 以下浏览器可以兼容Opacity:0.5;高版本浏览器可以兼容 Border-radius:10px; 可以写个圆角 补充部分flash1、插入 flash 1）语法： 123&lt;object width=\"value\" height=\"value\"&gt; &lt;embed width=\"value\" height=\"value\" src=\"flash路径及全称\"&gt;&lt;/embed&gt;&lt;/object&gt; 2）将 flash 背景设置为透明 1&lt;embed wmode=\"transparent\" /&gt; 给&lt;embed&gt;标记添加属性：wmode=”transparent” 说明：flash 源文件格式.fla,导出影片为.swf,创建播放器格式为.exe.gif 格式：.gif 滚动字幕12345678910&lt;marquee behavior（行为）=\"scroll(滚动)/alternate（晃动）\" direction（方向）=\"up(从下向上)/down（从上向下）/left（从右向左）/right（从左向右）\" scrollamount（滚动速度）=\"value\" height=\"value(上下滚动范围)\" width=\"\" (左右滚动范围)&gt; 滚动内容&lt;/marquee&gt; 滚动条Overflow 内容溢出时的设置 属性：overflow 水平及垂直方向内容溢出时的设置 overflow-x 水平方向内容溢出时的设置 overflow-y 垂直方向内容溢出时的设置 visible 默认值。使用该值时，无论设置的”width”和”height”的值是多少，其中的内容无论是否超出范围都将被强制显示。hidden 效果与 visible 相反。任何超出”width”和”height”的内容都会不可见。scroll 无论内容是否超越范围，都将显示滚动条。auto 当内容超出范围时，显示滚动条，否则不显示。 应用： 1)没有水平滚动条: 1&lt;div style=\"overflow-x:hidden\"&gt;test&lt;/div&gt; 2)没有垂直滚动条 1&lt;div style=\"overflow-y:hidden\"&gt;test&lt;/div&gt; 3)没有滚动条 123&lt;div style=\"overflow-x:hidden;overflow-y:hidden\" 或 style=\"overflow:hidden\"&gt; test&lt;/div&gt; 4)自动显示滚动条 1&lt;div style=\"height:100px;width:100px;overflow:auto;\"&gt;test&lt;/div&gt; 自己定义滚动条的颜色 12345678910body &#123; scrollbar-arrow-color: #f4ae21; /*图6,三角箭头的颜色*/ scrollbar-face-color: #333; /*图5,立体滚动条的颜色*/ scrollbar-3dlight-color: #666; /*图1,立体滚动条亮边的颜色*/ scrollbar-highlight-color: #666; /*图2,滚动条空白部分的颜色*/ scrollbar-shadow-color: #999; /*图3,立体滚动条阴影的颜色*/ scrollbar-darkshadow-color: #666; /*图4,立体滚动条强阴影的颜色*/ scrollbar-track-color: #666; /*图7,立体滚动条背景颜色*/ scrollbar-base-color: #f8f8f8; /*滚动条的基本颜色*/&#125; Cursor 定义个性鼠标1cursor: pointer/move/text/help/wait/w-resize/s-resize/sw-resize/se-resize/crosshair/auto/default/; 本文作者：人模人样的搬砖老段本文链接：定位锚点如有错误，请及时评论或者知乎私信或者 B 站私信哦~ 最后更新于:2020/03/11","tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"定位","slug":"定位","permalink":"http://yoursite.com/tags/%E5%AE%9A%E4%BD%8D/"},{"name":"锚点跳转","slug":"锚点跳转","permalink":"http://yoursite.com/tags/%E9%94%9A%E7%82%B9%E8%B7%B3%E8%BD%AC/"}]},{"title":"元素类型","date":"2018-09-23T09:29:12.000Z","path":"2018/09/23/元素类型/","text":"块元素(block) 块状元素在网页中就是以块的形式显示，所谓块状就是元素显示为矩形区域常用的块状元素包块 div,dl,dt,dd,ol,ul,fieldset,(h1-h6),p,form,hr,colgroup,col,table,tr,td,等; 块元素的特点： 1)默认情况下，块状元素都会独占一行，块状元素会按顺序自上而下排列。 2)块状元素都可以直接定义自己的宽度和高度。 3)块状元素遵循盒模型的所有规则，一般都作为其他元素的容器，它可以容纳其它内联元素和其它块状元素。（p 标签除外） 内联元素(inline) 或是行内元素 常见的内联元素如：a,span,i,em,strong,b 等 内联元素的特点： 1)内联元素其后如果是内联元素则会在一行内逐个进行显示； 2)内联元素显示的宽度、高度只能根据所包含内容的高度和宽度来确定，不能直接定义它的宽和高，它的最小内容单元也会呈现矩形形状； 3)内联元素也会遵循盒模型基本规则，但个别属性不能正确显示;（上下间距显示不正确，左右正常显示） 可变元素需要根据上下文关系确定该元素是块元素或者内联元素。 元素类型转换 display 的作用：设置或检索元素的类型。属性值 19 个：block/inline/inline-block/none/list-item/table-header-group/table-footer-group…. 属性值中有 5 个最常用的属性值1)Block块元素的 display 默认属性值，当给元素加 display：block 后元素变为块元素（注：当元素设置了 float 属性后，就相当于给该元素加了 display:block;属性；）2)inline内联元素的 display 默认属性值，当给元素加 display：inline 元素变为内联元素3)inline-block内联块元素默认属性值：行内的其他元素显示在同一行，但可以直接设置宽高，如：img,input（注：只有这一个元素类型支持 vertical-align 属性）4)none元素被隐藏不显示5)list-item将元素转换成列表。li 的 display 默认属性值； 总结 大部分块元素 display 属性值默认为 block，其中 li 默认值为 list-item。 大部分内联元素(行内元素、行间元素)的 display 属性值默认为 inline,其中 img,input，默认为 inline-block。 扩展置换元素：一个内容 不受 CSS 视觉格式化模型控制，CSS 渲染模型并不考虑对此内容的渲染，且元素本身一般拥有固有尺寸（宽度，高度，宽高比）的元素，被称之为置换元素。HTML 中的 img、input、textarea、select、object 都是置换元素。这些元素往往没有实际的内容，即是一个空元素 非置换元素：HTML 的大多数元素是不可替换元素，即其内容直接表现给用户端 本文作者：人模人样的搬砖老段本文链接：元素类型如有错误，请及时评论或者知乎私信或者 B 站私信哦~ 最后更新于:2020/01/04","tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"元素类型","slug":"元素类型","permalink":"http://yoursite.com/tags/%E5%85%83%E7%B4%A0%E7%B1%BB%E5%9E%8B/"}]},{"title":"CSS核心属性","date":"2018-09-09T01:16:00.000Z","path":"2018/09/09/CSS核心属性/","text":"CSS 简介Css 的三大特性（机制）：特殊性、继承性、层叠性 特殊性：就是之前说的权重；继承性：子元素会继承父元素的一些属性层叠性：样式产生冲突时，会如何加载 1)选择器权重大的优先加载 2)权重一样时，按照文件的读写顺序；后写的会覆盖先写的样式 属性：属性值 1)每个 css 样式都必须由两部分组成：选择符（Selector）和声明（Decleration）注：声明又包括属性（Properyt）和属性值（Value）2)css 属性：属性是指定选择符具有的属性，他是 css 的核心，css2 共有 150 多个属性；3)css 属性值：属性值包括法定属性值和常规的数值加单位或颜色值(colorValue)；如（25px）。 关于文本的 CSS 属性 文本大小：font-size:value;如：font-size：12px; 1)属性值为数值型时，必须给属性值加单位，属性值为 0 时除外。 2)单位还可以是 pt, 9pt=12px; 3)为了减小系统间的字体显示差异，IE Netscape Mozilla 的浏览器制作商于 1999 年召开会议，共同确定 16px/ppi 为标准字体大小默认值,即 1em.默认情况下，1em=16px,0.75em=12px; 4)使用绝对大小关键字xx-small=9pxx-small=11pxsmall=13pxmedium=16pxlarge=19pxx-large=23pxxx-large=27px 文本颜色 color:#颜色值;用十六进制表示颜色值：0 1 2 3 4 5 6 7 8 90 1 2 3 4 5 6 7 8 9 A B C D E F颜色模式：光色模式 R G BFF 00 00当表示三原色的三组数字同时相同时，可以缩写为三位;当用十六进制表示颜色值时颜色值前必须加”#” 文本字体font-family:字体 1；font-family:字体 1，字体 2，字体 3； 1)当字体是中文字体时必须加双引号；当英文字体名称是多个单词组成时需加双引号 2)当属性值是多个字体时，浏览器首先会寻找字体 1、如存在就使用改字体来显示内容，如在字体 1 不存在，则会寻找字体 2，如字体 2 也不存在，按字体 3 显示内容，如果字体 3 也不存在;则按系统默认字体显示。 加粗font-weight:bolder(更粗的)/bold（加粗）/normal（常规）/100—900;说明：100-500 常规字体 600-900 加粗字体 倾斜font-style:italic(倾斜度小)/oblique(倾斜度大)/normal(取消倾斜，常规显示)说明：italic 和 oblique 都表示倾斜，不过 oblique 的幅度要大一点。但一般浏览器对它们的区分不是很明显。 水平对齐方式text-align:left、right/center/justify（两端对齐中文不明显）; 垂直对齐方式vertical-align:top/bottom/middle;它不能单独使用，只能和 display 属性搭配使用 行高line-height:normal/值 1)当单行文本的行高等于容器高时，可实现单行文本在容器中垂直方向居中对齐； 2)当单行文本的行高小于容器高时，可实现单行文本在容器中垂直中齐以上任意位置的定位； 3)当单行文本的行高大于容器高时，可实现单行文本在容器中垂直中齐以下任意位置的定位。（IE6 及以下版本存在浏览器兼容问题）倍行高：{line-height:2;} 2 倍 ，{line-height:1.5;}1.5 倍；注：当使用倍行高为单位时，不加 PX; 文本修饰text-decoration:none（没有修饰）underline（添加下划线）overline（添加上划线）line-through（添加删除线） border:3px solid red;粗细（数值+单位） 线型（solid/dashed/dotted/double） 颜色; 右边框 border-right:左边框 border-left:上边框 border-top:下边框 border-bottom:solid:实线 dashed:虚线 dotted:点状线 double:双线 首行缩进：text-indent:value;1)text-indent 可以取负值;2)text-indent 属性只对第一行起作用。 缩进两个字符可以写：text-indent:2em; 文字属性简写：font:12px/1.5 “宋体”; font 的属性值应按以下次序书写(各个属性值之间用空格隔开)顺序: font-style font-weight font-size / line-height font-family 1)简写时 , font-size 和 line-height 只能通过斜杠/组成一个值，不能分开写。 2)顺序不能改变 ,这种简写法只有在同时指定 font-size 和 font-family 属性时才起作用,而且,你没有设定 font-weight , font-style 他们会使用缺省值。 字间距letter-spacing:value; 控制英文字母或汉字的字距。 词间距word-spacing:value; 控制英文单词词距。 控制文本大小写text-transform: capitalize(首字母大写)/uppercase（全大写）/lowercase（全小写） 小型大写字母font-variant: small-caps 文本流控制layout-flow:horizontal（自左向右）/vertical-ideographic（自上而下）;（注：此属性只有 IE 浏览器支持） 关于列表的 CSS 属性 定义列表符号样式list-style-type：disc(实心圆)/circle(空心圆)/square(实心方块)/none(去掉列表符号) 使用图片作为列表符号list-style-image：url(所使用图片的路径及全称) 定义列表符号的位置list-style-position:outside(外边)/inside(里边) list-style:none去掉列表符号 关于背景的 css 属性 背景颜色background-color:颜色值; 背景图片background-image:url(背景图片的路径及全称)；网页上有两种图片形式：插入图片、背景图; 插入图片：属于网页内容，也就是结构。背景图：属于网页的表现，背景图上可以显示文字、插入图片、表格等。 背景图片的显示原则 1)容器尺寸等于图片尺寸，背景图片正好显示在容器中; 2)容器尺寸大于图片尺寸，背景图片将默认平铺，直至铺满元素； 3)容器尺寸小于图片尺寸，只显示元素范围以内的背景图。 背景图片平铺background-repeat:no-repeat(不平铺)/repeat(平铺)/repeat-x(水平平铺)/repeat-y(垂直平铺) } 背景图片的位置background-position:值 1 值 2; 1)属性值有两个值组成，值 1 是水平位置的坐标值，值 2 是垂直位置的坐标值; 2)值 1 = left/center/right/数值;值 2 = top/center/bottom/数值;当两个值都是 center 的时候可缩小为一个; 3)当属性值是数值时，向右方向，向下方向正值。 背景属性的缩写语法：background:属性值 1 属性值 2 属性值 3；如:background:url (背景图片的路径及全称) no-repeat center top; 背景图的固定background-attachment:scroll(滚动)/fixed(固定); 网页上常用的图片格式(压缩图片)1)jpg:有损压缩格式，靠损失图片本身的质量来减小图片的体积，适用于颜色丰富的图像;(像素点组成的，像素点越多会越清晰)2)gif：有损压缩格式，靠损失图片的色彩数量来减小图片的体积，支持透明，支持动画，适用于颜色数量较少的图像;3)png:有损压缩格式，损失图片的色彩数量来减小图片的体积，支持透明，不支持动画，是 fireworks 的 源文件格式，适用于颜色数量较少的图像; 切图步骤: 1)选框工具画选区2)ctrl+c3)ctrl+n 回车键 ctrl+v4)ctrl+alt+shift+s 浮动属性float:none/left/right; 清除浮动（某一侧不出现浮动元素）Clear:both/left/right 1)加过浮动的元素会脱离文档流 2)想让并列的元素横着排，需要给并列的每个元素都加 float 本文作者：人模人样的搬砖老段本文链接：CSS 核心属性如有错误，请及时评论或者知乎私信或者 B 站私信哦~ 最后更新于:2019/11/08","tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"CSS基础","date":"2018-08-26T04:04:08.000Z","path":"2018/08/26/CSS基础/","text":"CSS 简介cascading style sheets 汉译:层叠样式表 WEB 标准中的表现标准语言,表现标准语言在网页中主要对网页信息的显示进行控制，简单说就是如何修饰网页信息的显示样式。目前推荐遵循的是 W3C 发布的 CSS3.0 用来表现 XHTML 或者 XML 等样式文件的计算机语言。1998 年 5 月 21 日由 w3C 正式推出的 css2.0 div+css 的优点： 缩减页面代码，提高访问速度;代码减少，页面文件就会小，占用网络带宽就少，客户端打开速度就快，用户体验会更好 结构清晰，有利于 seo有利于搜索引擎优化缩短改版时间对网站的重构有很好的支持弥补 html 语言的不足 CSS 语法选择符 {属性:属性值; 属性:属性值;} 选择符和声明 CSS 样式表说明: 1)每个 CSS 样式由两部分组成，即选择符和声明，声明又分为属性和属性值； 2)属性必须放在花括号中，属性与属性值用冒号连接。 3)每条声明用分号结束。 4)当一个属性有多个属性值的时候，属性值与属性值不分先后顺序。 5)在书写样式过程中，空格、换行等操作不影响属性显示。 内部样式表 123&lt;style type=\"text/css\"&gt; /*css语句*/&lt;/style&gt; 内联样式&lt;标签 style=”属性:属性值; 属性:属性值;”&gt;&lt;/标签&gt;例如： 12&lt;div style=“width:100px; height:100px; border:1px solid #eee; background:#fff;\"&gt;&lt;/div&gt; 外部样式表引用外部样式表文件方法一: 1&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"目标文件的路径及文件名全称\" /&gt; 说明：使用 link 元素导入外部样式表时，需将该元素写在文档头部，即与之间。rel：用于定义文档关联，表示关联样式表；type：定义文档类型；方法二: 123&lt;style type=\"text/css\"&gt; @import url(目标文件的路径及文件名全称);&lt;/style&gt; 注：@和 import 之间没有空格,url 和小括号之间也没有空格,必须结尾以分号结束; link 和 import 导入样式的区别 link 属于 XHTML 标签，而@import 完全是 CSS 提供的一种方式。 link 标签除了可以加载 CSS 外，还可以做很多其它的事情，比如定义 RSS，定义 rel 连接属性等，@import 就只能加载 CSS。 加载顺序的差别:当一个页面被加载的时候（就是被浏览者浏览的时候），link 引用的 CSS 会同时被加载，而@import 引用的 CSS 会等到页面全部被下载完再被加载。所以有时候浏览@import 加载 CSS 的页面时开始会没有样式。 兼容性的差别:@import 是 CSS2.1 提出的，所以老的浏览器不支持，@import 只 t 在 IE5 以上的才能识别，而 link 标签无此问题。 使用 dom 控制样式时的差别:当使用 javascript 控制 dom 去改变样式的时候，只能使用 link 标签，因为@import 不是 dom 可以控制的. 样式表的优先级内联样式最高外部样式和内部样式谁写在下面就会覆盖上面的样式，优先级更高 样式表的作用域内联样式只对当前标签起作用;内部样式只对当前文件起作用;外部样式对所有连接的页面都起作用; CSS 选择器CSS 选择符包括 4 大类:类型选择符、id 选择符、class 选择符、和特殊选择符; 常用的选择符有十种左右:类型选择符（标记选择器）类选择符 （class 选择符）ID 选择符 （id 选择器）伪类选择器群组选择符（集合选择器）通配符（*）子选择符包含选择符（后代选择器） 元素选择符/类型选择符 元素名称 { 属性：属性值；} 如 123p &#123; background: red;&#125; 说明：① 元素选择符即使用结构中元素名称作为选择符。如 body、div、p,img,em,strong,span……等。② 所有的页面元素都可以作为选择符;③ 使用元素选择器，会把文档中所有的标签都加相同的样式;如：a｛background:red｝ 所有 a 的背景颜色都是红色 id 选择器#id 名{属性：属性值;} 说明：① 使用 ID 选择器时需给元素定义 id 属性;如： 1&lt;div id=\"top\"&gt;&lt;/div&gt; ② 在 css 样式表中写 id 选择器时，id 名称前加#;如：#box{width:300px; height:300px;}③ 起 id 名时要取英文名，不能用关键字(所有的标记和属性都是关键字);如：head 标记④ 一个 id 名称只能对应文档中一个具体的元素; class 选择器/class 选择符.class 名{属性:属性值;} 说明：① 使用类选择符时需为元素定义一个 class 属性；如： 12&lt;div class=\"top\"&gt;&lt;/div&gt;“ ② 一个 class 属性可以起多个名字；如 1&lt;p class=\"box main\"&gt;&lt;/p&gt; 扩展：div.box{background:red;} 指定选择器 12&lt;div class=\"box\"&gt;&lt;/div&gt;&lt;p class=\"box\"&gt;&lt;/p&gt; 只会给 class 名为 box 的 div 标签加样式 群组选择器选择符 1，选择符 2，选择符 3{属性：属性值;} 说明：当有多个选择符应用相同的样式时,可以使用群组选择器; 包含选择器(后代选择器)选择符 1 选择符 2{属性：属性值;} 说明:选择符 1 和选择符 2 用空格隔开，选择符 1 中必须包含的所有选择符 2; 子元素选择器 选择符 1&gt;选择符 2{属性:属性值;} 说明:子元素选择器只能匹配父元素下的第一级子元素 伪类选择器(伪类选择符)a:link{属性：属性值;} 超链接的初始状态;a:visited{属性：属性值;} 超链接被访问后的状态;a:hover{属性：属性值;} 鼠标划过超链接时的状态;a:active{属性：属性值;} 即鼠标按下时超链接的状态 说明：① 当四个伪类选择器同时使用时，必须是以上的顺序;② 写网页时一般我们简化使用如：a{color:red;} a:hover{color:green;}表示超链接的三种状态都相同,只有鼠标划过变颜色。 通配符 {属性:属性值;} 说明：通配选择符的写法是”*“，其含义就是所有元素。用法：常用来重置样式 CSS 选择器的权重选择符的权重css 中用四位数字表示权重，权重的表达方式如：0,0,0,0类型选择符的权重：0001class 选择符的权重：0010id 选择符的权重：0100子选择符的权重：0000属性选择符的权重：0010伪类选择符的权重：0010伪元素选择符的权重：0010包含选择符的权重：包含的选择符权重值之和 内联样式的权重：1000继承样式的权重：0000 注释的写法HTML 注释 1&lt;!--注释的内容--&gt; CSS 的注释 1/*注释内容*/ 本文作者：人模人样的搬砖老段本文链接：CSS 基础如有错误，请及时评论或者知乎私信或者 B 站私信哦~ 最后更新于:2019/10/22","tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"HTML基础","date":"2018-08-11T16:09:55.000Z","path":"2018/08/12/HTML基础/","text":"Web 标准 结构 (xhtml、xml) 表现 (css)万维网联盟(w3c)制定了结构和表现的标准 行为 (Dom ECMAScript)欧洲电脑厂商联合会(ECMA)制定行为标准 关于 HTML 的相关概念 HTML 指的是超文本标记语言(Hyper Text Markup Language) XHTML 指可扩展超文本标记语言(标识语言)Extensible HyperText Markup Language HTML5 指的是 HTML 的第五次重大修改(新标准) HTML 的文件结构1234567891011121314&lt;!DOCTYPE html&gt;&lt;!--声明文档类型--&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;!--编码格式--&gt; &lt;title&gt;我的第一个网页&lt;/title&gt; &lt;!--文档标题--&gt; &lt;/head&gt; &lt;body&gt; 所有要写的内容 &lt;!--网页内容--&gt; &lt;/body&gt;&lt;/html&gt; HTML 的文件命名文件命名规则：用英文，不用中文 .html 和.htm; 无汉字、无空格、无特殊符号（如标点符号） 必须以英文开头，只可以有英文字母、下划线和数字； 首页的文件默认命名为：index.html 或 index.htm； HTML 的语法 &lt;标签名 属性名=“属性值”属性名=“属性值” &gt;文本&lt;/标签名&gt;例如： 1&lt;a href=\"“#”\" title=\"“这是一个连接”\"&gt;背景红色&lt;/a&gt; &lt;标签名 属性名=“属性值” /&gt;例如： 1&lt;img src=\"“图片地址”\" /&gt; 说明： 1)写在&lt;&gt;中的第一个单词叫做标记，标签，元素。 2)标记和属性用空格隔开，属性和属性值用等号连接，属性值必须放在””号内。 3)一个标记可以没有属性也可以有多个属性，属性和属性之间不分先后顺序。 4)单标记没有结束标签，用”/“代替。 HTML 的常用标记HTML 文本标记 文本标题标签 123456&lt;h1&gt;标题&lt;/h1&gt;&lt;h2&gt;标题&lt;/h2&gt;&lt;h3&gt;标题&lt;/h3&gt;&lt;h4&gt;标题&lt;/h4&gt;&lt;h5&gt;标题&lt;/h5&gt;&lt;h6&gt;标题&lt;/h6&gt; 特点：字体加粗、变大；自动换行 段落标签 1&lt;p&gt;段落文本内容&lt;/p&gt; 特点：段落与段落之间有段间距 定义粗体文本 1&lt;strong&gt;文本&lt;/strong&gt; &lt;b&gt;文本&lt;/b&gt; 定义斜体文本 1&lt;em&gt;文本&lt;/em&gt; &lt;i&gt;文本&lt;/i&gt; 定义下标字 1&lt;sub&gt;文本&lt;/sub&gt; 定义上标字 1&lt;sup&gt;文本&lt;/sup&gt; 定义删除字 1&lt;del&gt;文本&lt;/del&gt; 强制换行 &gt; 水平线 空格符 1&amp;nbsp; 列表标签HTML 中有三种列表，分别是：无序列表，有序列表，自定义列表 12345678910111213141516171819202122&lt;!-- 无序列表 --&gt;&lt;ul&gt; &lt;li&gt;内容&lt;/li&gt; &lt;li&gt;内容&lt;/li&gt; &lt;li&gt;内容&lt;/li&gt; ．．．．．．&lt;/ul&gt;&lt;!-- 有序列表 --&gt;&lt;ol&gt; &lt;li&gt;内容&lt;/li&gt; &lt;li&gt;内容&lt;/li&gt; &lt;li&gt;内容&lt;/li&gt; ．．．．．．&lt;/ol&gt;&lt;!-- 自定义列表 --&gt;&lt;dl&gt; &lt;dt&gt;名词&lt;/dt&gt; &lt;dd&gt;解释&lt;/dd&gt; ．．．．．．&lt;/dl&gt; HTML 的超链接标签1234&lt;!-- 新窗口打开 --&gt;&lt;a href=\"“#”\" target=\"_blank\" title=\"“”\"&gt;链接内容&lt;/a&gt;&lt;!-- 当前窗口打开 --&gt;&lt;a href=\"“#”\" target=\"_self\"&gt;链接内容&lt;/a&gt; HTML 的图片标记1&lt;img src=\"目标文件路径及全称\" alt=\"图片替换文本\" title=\"图片标题\" /&gt; title 的作用: 当鼠标悬停在该图片上时显示一个小提示，鼠标离开就没有了（注：HTML 的绝大多数标签都支持 title 属性，title 属性就是专门做提示信息的）alt 的作用:当图片因为某种原因不能正常加载时，在图片位置显示的提示信息 HTML 相对路径的写法 当前文件与目标文件在同一目录下: 1&lt;img src=\"img01.jpg\" /&gt; 当前文件与目标文件所处的文件夹在同一目录下: 1&lt;img src=\"images/img01.jpg\" /&gt; 当前文件所处的文件夹和目标文件所处的文件夹在同一目录下: 1&lt;img src=\"../images/img01.jpg\" /&gt; HTML 数据表格的作用及组成表格的基本构成 123456789101112&lt;table width=\" 500\" height=\"300 \" border=\"1\" bgcolor=\"red\" cellspacing=\"5\" cellpadding=\"0\"&gt; &lt;tr&gt; &lt;td&gt;内容&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 注：一个 tr 表示一行; 一个 td 表示一列(一个单元格) 表格的相关属性: 单元格与单元格之间的间距：cellspacing=”20”单元格与内容之间的空隙：cellpadding=”10”水平对齐方式：align=”left/center/right”(注:如果此属性加到 table 上表示 table 相对于浏览器的对齐方式;如果加到 tr 或 td 上表示单元格内容相对于单元格的对齐方式。)垂直对齐：valign=”top/middle/bottom” 合并单元格属性：合并列：colspan=”所合并的列数”合并行：rowspan=”所合并的行数” HTML 表单的应用表单框 1&lt;form name=“name01” method=“post/get” action=“ ”&gt;内容&lt;/form&gt; 称为表单标记，属于一个容器标记，表示其它表单标记需要在它的包围中才有效。 单行文本框 1&lt;input name=\"“\" ” type=\"“text”\" value=\"默认值\" /&gt; 密码框 1&lt;input name=\"“”\" type=\"password\" placeholder=\"密码\" /&gt; 提交按钮 1&lt;input type=\"submit\" value=\"按钮内容\" /&gt; 重置按钮 1&lt;input type=\"reset\" value=\"按钮内容\" /&gt; 普通按钮 1&lt;input type=\"“button”value\" =\"“下一步”\" /&gt; HTML div 和 span 的用法 div 的用法 12&lt;div id=\"id名“ class=\"class名\"&gt;&lt;/div&gt;&lt;!-- 文档区域，文档布局对象 --&gt; span 的用法 12&lt;span&gt;&lt;/span&gt;&lt;!-- 文本结点（某一小段文本，或是某一个字） --&gt; post 和 get 的区别 get 是从服务器上获取数据，post 是向服务器传送数据 get 是把参数数据队列加到提交表单的 ACTION 属性所指的 URL 中，在 URL 中可以看到。post 是通过 HTTP post 机制，用户看不到这个过程 get 传送的数据量较小，不能大于 2KB。post 传送的数据量较大，一般被默认为不受限制。 get 安全性非常低，post 安全性较高。但是执行效率却比 Post 方法好。 本文作者：人模人样的搬砖老段本文链接：HTML 基础如有错误，请及时评论或者知乎私信或者 B 站私信哦~ 最后更新于:2020/04/11","tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]}]